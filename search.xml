<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>体验Fcitx5</title>
      <link href="/2020/09/27/ti-yan-fcitx5/"/>
      <url>/2020/09/27/ti-yan-fcitx5/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><blockquote><p>一直以来，我在Linux平台上的输入法体验都不是很好（<del>我太菜了</del>），最近在狗舍友的安利下，尝试了Fcitx5。<br>目前使用了一个多月，体验良好，统一了我在不同平台的输入法体验。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h2><blockquote><p>可使用以下命令直接安装：</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">sudo pacman -S fcitx5-im fcitx5-chinese-addons<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>另外 CN 源有词库可用</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">sudo pacman -S fcitx5-pinyin-{zhwiki,moegirl}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>我没有尝试过，请谨慎使用以下方法：</p><pre class="line-numbers language-txt"><code class="language-txt">用Ubuntu官方源安装fcitx5sudo apt install fcitx5 fcitx5-pinyin fcitx5-chinese-addons fcitx5-frontend-gtk2 fcitx5-frontend-gtk3 fcitx5-frontend-qt5然后再添加ppa安装kde-config-fcitx5sudo add-apt-repository ppa:hosxy/testsudo apt update然后千万不要升级任何软件包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><blockquote><p>这点是我最满意的地方了，Material Color主题配置很简单，同时又和Win10输入法很类似，挺好看的，强烈安利。<br>目前主题美化有以下几种选择：</p></blockquote><ul><li><code>kimpanel</code>(KDE)/<code>gnome-shell-extension-kimpanel</code>(Gnome) （同时这也应该是目前 Wayland 下唯一的方案）</li><li><a href="https://github.com/hosxy/Fcitx5-Material-Color" target="_blank" rel="noopener">Material Color</a>主题，有多种颜色以及单行双行两种模式，Arch 官方源有打包</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记人生第一次刷机</title>
      <link href="/2020/07/31/ji-ren-sheng-di-yi-ci-shua-ji/"/>
      <url>/2020/07/31/ji-ren-sheng-di-yi-ci-shua-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="记人生第一次刷机"><a href="#记人生第一次刷机" class="headerlink" title="记人生第一次刷机"></a>记人生第一次刷机</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在昨天晚上翻东西的时候，突然看到我初中时候用的一台华为P7，真的是相当有感触的一部手机，玻璃面板很漂亮，同时也记录了我的<del>青春</del>。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/574e9258d109b3de751162e0c6bf6c81810a4c88?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxNTA=,g_7,xp_5,yp_5" alt="华为P7"></p><p>开机以后，查看了处理器是海思Kirin910T，相当有年代感了，2G内存，16G硬盘，还是移动定制版P7-L07。系统是EMUI3.1，为Android5.1的版本。整体运行起来并不流畅，卡顿感还是很明显的。</p><p>于是就想折腾一下这位老将，看看廉颇老矣，尚能饭否。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先继承我一贯良好的备份作风，查看了手机里还有什么值得保存的东西。结果让我发现了一股浓重的初中中二气息。。。最惊讶的是发现了好多朋友的黑历史，哈哈哈哈哈哈。<del>可以拿去嘲笑他们了</del></p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>通过查阅资料，得知P7必须要root以及解锁Bootloader才能刷机。</p><p>无奈，先通过了kingroot软件对P7进行了root。</p><p>随后，了解到华为在2018年关闭了Bootloader解锁申请，当时人就裂开了，第一次刷机就遇到这种骚操作。</p><p>看了看淘宝解锁还是要好几块大洋的，实在舍不得，就开始网上扒资料，最后真让我在xda找到一个打包好的提取解锁码的脚本。之后就简单了，利用工具或者命令行填入解锁码就解锁成功了。</p><p>不过华为P7的包确实是难找，实在是太少了。大多都是基于Android4.4和Android5.1的MIUI以及Flyme系统，实在是太破了。</p><p>皇天不服有心人，最终在xda找到一个P7-L00联通定制机的包，基于Android6.0的lineage13系统。</p><p>于是开始疯狂补习如何刷机的知识，先刷入了twrp3.0的rec，随后直接刷入los13成功！起飞！</p><p>接下来，我又查看资料，刷入了面具20.0。</p><p>好景不长，在我找到一个内核超频包并刷入后，给整黑了。。。。当时就整蒙蔽了。才看到这个内核超频包只在原官方EMUI3.1系统上测试过，人傻了。</p><p>又发现twrp给我更新到了3.3.2，这个版本刷不上那个los13的包了，尴尬。又刷回官方rec，再刷最开始的twrp3.0，再重新刷的los13和面具20.0，玩了一圈又回去了，emmmmmmmmmm</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>有了P7成功的经验，我又翻出来一台乐视Max2，这台可是高通火龙820的机子，总能玩出点有趣的了。</p><p>最后刷了一个基于一加5t魔改的H2OS的包。</p><p>emmmmmm，真香！</p><p><del>看着自己手里的主力MIUI12，露出了笑容。</del></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题美化(二)</title>
      <link href="/2020/07/29/matery-zhu-ti-mei-hua-er/"/>
      <url>/2020/07/29/matery-zhu-ti-mei-hua-er/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇 <a href="https://www.gapcolt.com/2020/07/29/matery-zhu-ti-mei-hua-yi/">传送门</a></p></blockquote><h3 id="2-3-添加功能插件"><a href="#2-3-添加功能插件" class="headerlink" title="2.3 添加功能插件"></a>2.3 添加功能插件</h3><h4 id="2-3-1代码高亮"><a href="#2-3-1代码高亮" class="headerlink" title="2.3.1代码高亮"></a>2.3.1代码高亮</h4><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的tomorrow还是挺丑的，我使用了material-dark主题</p><h4 id="2-3-2搜索"><a href="#2-3-2搜索" class="headerlink" title="2.3.2搜索"></a>2.3.2搜索</h4><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3中文链接转拼音（建议安装）"><a href="#2-3-3中文链接转拼音（建议安装）" class="headerlink" title="2.3.3中文链接转拼音（建议安装）"></a>2.3.3中文链接转拼音（建议安装）</h4><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h4 id="2-3-4文章字数统计插件（建议安装）"><a href="#2-3-4文章字数统计插件（建议安装）" class="headerlink" title="2.3.4文章字数统计插件（建议安装）"></a>2.3.4文章字数统计插件（建议安装）</h4><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-5添加emoji表情支持（可选的）"><a href="#2-3-5添加emoji表情支持（可选的）" class="headerlink" title="2.3.5添加emoji表情支持（可选的）"></a>2.3.5添加emoji表情支持（可选的）</h4><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis" target="_blank" rel="noopener">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm install hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-6添加-RSS-订阅支持（可选的）"><a href="#2-3-6添加-RSS-订阅支持（可选的）" class="headerlink" title="2.3.6添加 RSS 订阅支持（可选的）"></a>2.3.6添加 RSS 订阅支持（可选的）</h4><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">npm install hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h4 id="2-3-7添加-DaoVoice-在线聊天功能（可选的）"><a href="#2-3-7添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="2.3.7添加 DaoVoice 在线聊天功能（可选的）"></a>2.3.7添加 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 在线聊天功能（可选的）</h4><p>前往 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h4 id="2-3-8添加-Tidio-在线聊天功能（可选的）"><a href="#2-3-8添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="2.3.8添加 Tidio 在线聊天功能（可选的）"></a>2.3.8添加 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 在线聊天功能（可选的）</h4><p>前往 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="2-4-修改页脚"><a href="#2-4-修改页脚" class="headerlink" title="2.4 修改页脚"></a>2.4 修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="2-5-修改社交链接"><a href="#2-5-修改社交链接" class="headerlink" title="2.5 修改社交链接"></a>2.5 修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code>&lt;% if (theme.socialLink.github) { %&gt;    &lt;a href=&quot;&lt;%= theme.socialLink.github %&gt;&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&gt;        &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;    &lt;/a&gt;&lt;% } %&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="2-6-修改打赏的二维码图片"><a href="#2-6-修改打赏的二维码图片" class="headerlink" title="2.6 修改打赏的二维码图片"></a>2.6 修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="2-7-配置音乐播放器（可选的）"><a href="#2-7-配置音乐播放器（可选的）" class="headerlink" title="2.7 配置音乐播放器（可选的）"></a>2.7 配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre><code># 是否在首页显示音乐music:  enable: true  title:             # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: &#39;#42b983&#39;  loop: &#39;all&#39;       # 音频循环播放, 可选值: &#39;all&#39;, &#39;one&#39;, &#39;none&#39;  order: &#39;random&#39;   # 音频循环顺序, 可选值: &#39;list&#39;, &#39;random&#39;  preload: &#39;auto&#39;   # 预加载，可选值: &#39;none&#39;, &#39;metadata&#39;, &#39;auto&#39;  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><pre><code>id`获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，`playlist`的`id</code></pre><p>即为这串数字。</p></blockquote><h3 id="2-8-文章-Front-matter-介绍"><a href="#2-8-文章-Front-matter-介绍" class="headerlink" title="2.8 文章 Front-matter 介绍"></a>2.8 文章 Front-matter 介绍</h3><h4 id="2-8-1Front-matter-选项详解"><a href="#2-8-1Front-matter-选项详解" class="headerlink" title="2.8.1Front-matter 选项详解"></a>2.8.1Front-matter 选项详解</h4><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h4 id="2-8-2最简示例"><a href="#2-8-2最简示例" class="headerlink" title="2.8.2最简示例"></a>2.8.2最简示例</h4><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---</code></pre><h4 id="2-8-3最全示例"><a href="#2-8-3最全示例" class="headerlink" title="2.8.3最全示例"></a>2.8.3最全示例</h4><pre><code>---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h4 id="2-8-4修改默认Front-matter"><a href="#2-8-4修改默认Front-matter" class="headerlink" title="2.8.4修改默认Front-matter"></a>2.8.4修改默认Front-matter</h4><p>修改/scaffolds/post.md这个文件，以后你新创建博客后默认会以它为Front-matter模板</p><h3 id="2-9-主题内可自定制修改"><a href="#2-9-主题内可自定制修改" class="headerlink" title="2.9 主题内可自定制修改"></a>2.9 主题内可自定制修改</h3><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="2-10-修改主题颜色"><a href="#2-10-修改主题颜色" class="headerlink" title="2.10 修改主题颜色"></a>2.10 修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre><code>/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="2-11-修改-banner-图和文章特色图"><a href="#2-11-修改-banner-图和文章特色图" class="headerlink" title="2.11 修改 banner 图和文章特色图"></a>2.11 修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre><code>$(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);</code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h3 id="2-12-其他"><a href="#2-12-其他" class="headerlink" title="2.12 其他"></a>2.12 其他</h3><blockquote><p>其余的在/themes/matery/_config.yml文件中基本都能找到</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题美化(一)</title>
      <link href="/2020/07/29/matery-zhu-ti-mei-hua-yi/"/>
      <url>/2020/07/29/matery-zhu-ti-mei-hua-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Matery主题配置"><a href="#Matery主题配置" class="headerlink" title="Matery主题配置"></a>Matery主题配置</h1><blockquote><p>说明：推荐搭配另外两篇博客一起使用：</p><blockquote><p>基础篇：Hexo主题美化(一)    <a href="https://www.gapcolt.com/2020/07/29/matery-zhu-ti-mei-hua-yi/">本篇</a></p><p>进阶篇：Matery主题美化(二)    <a href="https://www.gapcolt.com/2020/07/29/matery-zhu-ti-mei-hua-er/">传送门</a></p></blockquote></blockquote><h2 id="1-主题下载与安装"><a href="#1-主题下载与安装" class="headerlink" title="1. 主题下载与安装"></a>1. 主题下载与安装</h2><h3 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h3><p>点击 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">传送门</a> 前往Matery主题官方页面，下载主题文件并复制到themes文件夹下</p><p>当然你也可以在你的站点目录文件夹下使用 git clone 命令来下载：直接在站点根目录下执行下面的命令，即可进行主题的下载，主题有两个版本，稳定版本和最新版本 (不定期更新优化)，自主选择版本。</p><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/blinkfox/hexo-theme-matery themes/matery     # 稳定版git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery   #最新版(不定期进行优化更新)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-切换主题"><a href="#1-2-切换主题" class="headerlink" title="1.2 切换主题"></a>1.2 切换主题</h3><blockquote><p>注意：首先需要明白什么是站点配置文件，什么是主题配置文件，站点配置文件就是根目录下的配置文件，比如我的博客文件在 ~\blog 下，那么站点配置文件就是 ~\blog\ _config.yml，主题配置文件就是 ~\blog\themes\matery\ _config.yml。</p><p>另外注意，配置文件中的标点符号不要出现中文格式的标点符号，不然运行会出错。</p></blockquote><p>主题下载完成后，将站点配置文件中的 theme 值修改为你下载主题的文件夹名，此处为 matery，那么值就修改为 theme: matery。</p><p>一些站点配置文件的其他地方的修改： </p><ul><li>语言选择：如果为中文用户，则在 language: 后添加值 zh-CN，如果不修改，默认为英语。</li><li>网址修改：url: 的值为你的网址名，如 <a href="http://xxxx.github.io，如果有域名，则修改为你的域名即可。" target="_blank" rel="noopener">http://xxxx.github.io，如果有域名，则修改为你的域名即可。</a></li><li>站点配置文件有个 per_page属性，建议修改为 6 的倍数，这样网站在适应设备时，有较好的显示效果。matery主题修改为12或者18即可。</li></ul><h2 id="2-主题基础配置"><a href="#2-主题基础配置" class="headerlink" title="2 主题基础配置"></a>2 主题基础配置</h2><h3 id="2-1-新建页面"><a href="#2-1-新建页面" class="headerlink" title="2.1 新建页面"></a>2.1 新建页面</h3><h4 id="2-1-1新建分类-categories-页"><a href="#2-1-1新建分类-categories-页" class="headerlink" title="2.1.1新建分类 categories 页"></a>2.1.1新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo new page "categories"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2新建标签-tags-页"><a href="#2-1-2新建标签-tags-页" class="headerlink" title="2.1.2新建标签 tags 页"></a>2.1.2新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo new page "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-3新建关于我-about-页"><a href="#2-1-3新建关于我-about-页" class="headerlink" title="2.1.3新建关于我 about 页"></a>2.1.3新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4新建留言板-contact-页（可选的）"><a href="#2-1-4新建留言板-contact-页（可选的）" class="headerlink" title="2.1.4新建留言板 contact 页（可选的）"></a>2.1.4新建留言板 contact 页（可选的）</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo new page "contact"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="2-1-5新建友情链接-friends-页（可选的）"><a href="#2-1-5新建友情链接-friends-页（可选的）" class="headerlink" title="2.1.5新建友情链接 friends 页（可选的）"></a>2.1.5新建友情链接 friends 页（可选的）</h4><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">hexo new page "friends"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token string">"avatar"</span><span class="token punctuation">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token string">"introduction"</span><span class="token punctuation">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">"avatar"</span><span class="token punctuation">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token string">"introduction"</span><span class="token punctuation">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">"avatar"</span><span class="token punctuation">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token string">"introduction"</span><span class="token punctuation">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token string">"url"</span><span class="token punctuation">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-6新建-404-页"><a href="#2-1-6新建-404-页" class="headerlink" title="2.1.6新建 404 页"></a>2.1.6新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><p>编辑你刚刚新建的页面文件 <code>/source/404.md</code>，至少需要以下内容：</p><pre class="line-numbers language-txt"><code class="language-txt">---title: 404date: 2018-09-30 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>紧接着再新建主题文件夹的 layout 目录下新建 404.ejs 文件，添加内容如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">/* don't remove. */</span>    <span class="token punctuation">.</span>about<span class="token operator">-</span>cover <span class="token punctuation">{</span>        height<span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">.</span>2vh<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"bg-cover pd-header about-cover"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"row"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col s10 offset-s1 m8 offset-m2 l8 offset-l2"</span><span class="token operator">></span>                <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"brand"</span><span class="token operator">></span>                    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title center-align"</span><span class="token operator">></span>                        <span class="token number">404</span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>                    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"description center-align"</span><span class="token operator">></span>                        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> page<span class="token punctuation">.</span>description <span class="token operator">%</span><span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token comment" spellcheck="true">// 每天切换 banner 图.  Switch banner image every day.</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.7/source/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后部署，再看看效果即可。</p><h3 id="2-2-菜单导航配置"><a href="#2-2-菜单导航配置" class="headerlink" title="2.2 菜单导航配置"></a>2.2 菜单导航配置</h3><h4 id="2-2-1配置基本菜单导航的名称、路径url和图标icon"><a href="#2-2-1配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="2.2.1配置基本菜单导航的名称、路径url和图标icon."></a>2.2.1配置基本菜单导航的名称、路径url和图标icon.</h4><ul><li><p>菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>) </p></li><li><p>图标icon 可以在<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中查找</p></li></ul><pre class="line-numbers language-yml"><code class="language-yml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2二级菜单配置方法"><a href="#2-2-2二级菜单配置方法" class="headerlink" title="2.2.2二级菜单配置方法"></a>2.2.2二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作<br>1.在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)<br>2.在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.<br>3.注意每个二级菜单模块前要加 <code>-</code>.<br>4.注意缩进格式</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Musics        <span class="token key atrule">url</span><span class="token punctuation">:</span> /musics        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt扫雷项目</title>
      <link href="/2020/07/16/qt-sao-lei-xiang-mu/"/>
      <url>/2020/07/16/qt-sao-lei-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="MineSweeper"><a href="#MineSweeper" class="headerlink" title="MineSweeper"></a>MineSweeper</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>​    本项目以Qt为开发环境，设计并开发一款类似windows xp系统上的经典游戏：扫雷。这款经典的游戏不仅可以让人们充分享受娱乐，还可以锻炼人的逻辑推理能力和判断能力。</p><p>​    用户界面由一定数量的小方格组成的方块构成。当游戏开始时，计算机将随机设置雷区。此游戏还允许玩家调整难度。</p><h2 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h2><p><a href="https://github.com/horel/Qt_MineSweeper.git" target="_blank" rel="noopener">github项目源码地址</a></p><h2 id="总体规划"><a href="#总体规划" class="headerlink" title="总体规划"></a>总体规划</h2><p><img src="aa.jpg" alt=""></p><h2 id="实现需求并展示"><a href="#实现需求并展示" class="headerlink" title="实现需求并展示"></a>实现需求并展示</h2><p>扫雷以满足用户娱乐、益智为宗旨，以用户需求为导向，实现以下主要功能：</p><ul><li><p>游戏的初始化</p></li><li><p>雷区的随机自动生成</p></li><li><p>重新开始功能</p></li><li><p>第一次点击不为雷设置</p></li><li><p>菜单栏功能的实现</p></li><li><p>游戏难度的选择</p></li><li><p>自定义游戏难度</p></li><li><p>对游戏时间进行计时</p></li><li><p>对剩余雷数进行统计</p></li><li><p>绘制好游戏框架，实现笑脸重新开始功能</p></li><li><p>鼠标的不同点击事件（左键、右键、左右键同时按）</p></li><li><p>Help菜单栏的两项具体内容</p></li></ul><h2 id="具体实现介绍"><a href="#具体实现介绍" class="headerlink" title="具体实现介绍"></a>具体实现介绍</h2><h3 id="CMineMap类"><a href="#CMineMap类" class="headerlink" title="CMineMap类"></a>CMineMap类</h3><p><strong>_ 首先我先自己定义了一个CMineMap类来实现所有扫雷相关的操作：_</strong></p><p><img src="image-20200716174945530.png" alt="0"></p><ul><li><p>其中 Create( ) 和 Create(int, int, int) 都是通过先释放Map的空间，再根据行数、列数、雷数动态的申请空间，设好行数、列数、雷数，最后是调用Restart( ) 函数实现的。</p></li><li><p>ctnflag函数是统计（m，n）这个格子下四周的🚩数目，方便后面左右键一起点击事件的判定</p></li><li><p>Map使用指针方便动态分配空间</p></li><li><p>在未被点开时，Map(m)(n)  取值范围为 99–108</p><ul><li>其中99代表雷， 100–108代表周围雷的数目</li></ul></li><li><p>在点开时，Map(m)(n)  取值范围为 -1 – 8</p><ul><li>其中-1代表雷， 0–8代表周围雷的数目</li></ul></li><li><p>在插旗时，Map 取值范围49–58</p><ul><li>49代表雷， 50–58雷数</li></ul></li><li><p>函数介绍</p></li></ul><h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p><strong>左击事件</strong></p><p>当一个格子（坐标为(x,y)）被点下，如果个格子周围有雷，则Map[x][y]值为101-108，将这个值减去100就行了</p><p>重点：</p><p>如果周围都没有雷，就会爆出一大片。</p><p>刚开始感觉很难实现，这形状完全不规则，一行行一列列去检测都难以实现．但仔细一想其实这个问题很好解决，当点下发现这地方周围都没雷的时候就递归的点击周围８个格子就行了。</p><p><img src="image-20200716180746023.png" alt="1"></p><ul><li>first代表第一次点击的flag，点击后将flag设为0</li></ul><p><strong>右击事件</strong></p><p>右击一下插个红旗，在点一下小旗取消，实现起来很简单，点一下减50再点下加50就行了。</p><p><strong>左右键同时按下</strong></p><p>如果一个格子周围所有雷都被标记，在这个格子上同时按下鼠标左右键，剩余未被点开的格子就会全被点开．实现起来也不难，调用函数周围都点一遍就行了。</p><h3 id="Help菜单栏"><a href="#Help菜单栏" class="headerlink" title="Help菜单栏"></a>Help菜单栏</h3><p>about和How to play直接使用QMessageBox</p><h3 id="game菜单栏"><a href="#game菜单栏" class="headerlink" title="game菜单栏"></a>game菜单栏</h3><p><img src="image-20200716182512337.png" alt="2"></p><h2 id="自定义菜单子页面"><a href="#自定义菜单子页面" class="headerlink" title="自定义菜单子页面"></a>自定义菜单子页面</h2><p>子页面没有用设计师界面类</p><p><img src="image-20200716181836060.png" alt=""></p><p>较为简单，于是直接使用代码设置界面：</p><p>自定义设置并检测设置是否合理</p><p>IsReal是作为雷区是否合理的flag</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><ul><li><p>雷区</p></li><li><p>框架</p></li></ul><p><img src="image-20200716195537234.png" alt=""></p><p>winf可以作为flag，选择不同的笑脸。</p><ul><li><p>剩余雷数</p></li><li><p>进行时间</p></li></ul><p>QPainter是Qt中的一个绘图类，用该类中的drawPixmap函数来贴图片．</p><p>drawPixMap这个函数做的很完善，这个函数有11个同名函数，我用的是这一个</p><p>可以绘制 一部分 图像，可以剪切大小</p><pre class="line-numbers language-c++"><code class="language-c++">void    drawPixmap(int x, int y, const QPixmap & pixmap, int sx, int sy, int sw, int sh)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="鼠标消息处理"><a href="#鼠标消息处理" class="headerlink" title="鼠标消息处理"></a>鼠标消息处理</h3><p>Qt 中添加鼠标消息很容易，直接重载父类的mousePressEvent函数</p><p>通过event-&gt;button()和event-&gt;buttons()可以获取到底是哪个键被按下</p><p>通过event-&gt;x()和event-&gt;y()获取鼠标按下的坐标。根据这个坐标计算出点到哪一格，然后调用扫雷类的相关操作。</p><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p><img src="image-20200716181533562.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fcitx皮肤安装</title>
      <link href="/2020/05/27/fcitx-pi-fu-an-zhuang/"/>
      <url>/2020/05/27/fcitx-pi-fu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Fcitx输入法皮肤安装"><a href="#Fcitx输入法皮肤安装" class="headerlink" title="Fcitx输入法皮肤安装"></a>Fcitx输入法皮肤安装</h1><ul><li>Fcitx小企鹅输入法应该是Linux上较为广泛使用的输入法框架了，但是Linux下的搜狗输入法有时候还是有很多小问题的，使用起来会很糟心。因此我使用了Google拼音，目前使用状况良好。</li><li>可是搜狗输入法还是有很多好看的皮肤可以安装的，这些皮肤在Fcitx框架下的其他输入法中不能直接使用。</li><li>所以我写了这篇博客来把搜狗输入法的皮肤转换为Fcitx通用的皮肤。<h2 id="皮肤转换方法"><a href="#皮肤转换方法" class="headerlink" title="皮肤转换方法"></a>皮肤转换方法</h2><h3 id="皮肤下载"><a href="#皮肤下载" class="headerlink" title="皮肤下载"></a>皮肤下载</h3>先去搜狗官网下载自己喜欢的皮肤。<blockquote><p><a href="https://pinyin.sogou.com/skins/" target="_blank" rel="noopener">搜狗皮肤官网</a></p></blockquote><h3 id="使用开源工具转换"><a href="#使用开源工具转换" class="headerlink" title="使用开源工具转换"></a>使用开源工具转换</h3>前往大佬的github仓库查看。<blockquote><p><a href="https://github.com/VOID001/ssf2fcitx.git" target="_blank" rel="noopener">开源工具网站</a></p></blockquote></li></ul><p>使用下行命令将软件clone到本地</p><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/VOID001/ssf2fcitx.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后根据网站的说明，只需要将下载好的搜狗皮肤放到转换工具文件夹下，</p><p>再使用下列命令转换</p><pre class="line-numbers language-shell"><code class="language-shell">./ssf2skin -i 搜狗皮肤名.ssf -o 转换出的名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即</p><pre class="line-numbers language-shell"><code class="language-shell">./ssf2skin -i input.ssf -o output_dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到目录下皮肤以及转换完成</p><p>然后将转换好的皮肤复制到Fcitx存放皮肤的路径，根据发行版的不同一般在</p><pre class="line-numbers language-shell"><code class="language-shell">$XDG_CONFIG_HOME/fcitx/skin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-shell"><code class="language-shell">/usr/share/fcitx/skin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用皮肤"><a href="#使用皮肤" class="headerlink" title="使用皮肤"></a>使用皮肤</h3><p>右击Fcitx托盘图标，点击配置，进入外观，可以看到皮肤中已经有了自己安装的皮肤。</p><p>点开显示高级选项，填入需要使用的皮肤名称，即之前自定义转换出的名字。</p><p>那么可以看到，皮肤已经可以正常使用了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux动态壁纸</title>
      <link href="/2020/05/26/linux-dong-tai-bi-zhi/"/>
      <url>/2020/05/26/linux-dong-tai-bi-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux动态壁纸"><a href="#Linux动态壁纸" class="headerlink" title="Linux动态壁纸"></a>Linux动态壁纸</h1><blockquote><p>注意：因为此软件消耗性能较大，作者已经弃用！也并不推荐大家使用！</p></blockquote><pre><code>+ 本着提高生产力的目的，我觉得用动态壁纸美化桌面应该还是有必要的～～+ ~~美化一时爽，内存火葬厂~~</code></pre><h2 id="Komorebi"><a href="#Komorebi" class="headerlink" title="Komorebi"></a>Komorebi</h2><p>  我使用的是komorebi这个软件进行动态壁纸美化的，使用也比较简单。</p><p>  如果像我一样使用的是Arch系的话可以直接输入下列命令安装：</p><pre class="line-numbers language-shell"><code class="language-shell">  sudo pacman -S komorebi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  而如果是使用其他系的Linux的话可以先试试自己的发行版有没有<code>komorebi</code>这个包，<br>  如果没有的话可以去该项目的网站<br>  <a href="https://github.com/cheesecakeufo/komorebi" target="_blank" rel="noopener">komorebi网站</a><br>  查看，自己手动编译安装。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>  打开Komorebi后可以看见是这样的，可以自己换壁纸和设置。<br> <img src="komorebi.png" alt="Komorebi"></p><p>  如果想自己创建壁纸的话，打开安装好的Wallpaper Creator界面即可自定义了，根据提示来即可。<br> <img src="wallperCreator.png" alt="Wallpaper Creator"></p><ul><li>注意：创建好后最后有个命令需要在终端输入！<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></li><li>右键桌面是换壁纸和设置。</li><li>壁纸全部储存在<code>/usr/share/Komorebi/</code>下，可以把默认自带的壁纸删除，实测没影响<del>壁纸全是文件夹，别把其他的删了</del></li><li><del>放了个200M的视屏，内存大概少了一个G。。。凎，希望后期能优化下吧</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp定律</title>
      <link href="/2020/04/11/esp-ding-lu/"/>
      <url>/2020/04/11/esp-ding-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>疫情期间闲着也是闲着，在逆向某软件时深入了解了下ESP定律，然后就想写个文章记录并分享下。</p><blockquote><p>ESP定律又称堆栈平衡定律，是应用频率最高的脱壳方法之一 ,不论是新手还是老手都经常用到。据我所知，ESP定律是一位外国大牛发现的，但目前已无从考证（未找到相关资料）。</p></blockquote><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>栈（stack）是内存中分配的一段空间。 向一个栈插入新元素又称作入（push）放到栈顶元素的上面，使之成为新的栈顶元素； 从一个栈删除元素又称作出栈（pop），它把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-db37399e8427d7ef83e0a6c86db89167_720w.jpg" alt="img"></p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>相当于高级语言中的函数调用。 当执行call指令时，进行两步操作： 将下一条的指令的地址压入栈中，再跳转到该地址处。 相当于：</p><pre class="line-numbers language-text"><code class="language-text">push ipjmp near ptr 地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ret-amp-amp-retf"><a href="#ret-amp-amp-retf" class="headerlink" title="ret &amp;&amp; retf"></a>ret &amp;&amp; retf</h3><blockquote><p>与call指令相对应，将当前的ESP寄存器中指向的地址出栈，然后跳转到这个地址。 相当于：</p></blockquote><pre class="line-numbers language-text"><code class="language-text">pop ip#retpop IPpop CS#retf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-操作示例"><a href="#0x02-操作示例" class="headerlink" title="0x02 操作示例"></a>0x02 操作示例</h2><p>这是我写的一个带壳的32位小程序，用来当做esp定律应用的一个示例。这是一个比较机械的方法，但可以对esp定律有一个感性的认识。</p><p>首先用Exeinfo Pe查壳，发现是nspack壳。</p><p><img src="https://pic3.zhimg.com/80/v2-0f26eba4d20b6042fe8bc6bca439c9ea_720w.jpg" alt="img"></p><p>接下来用od载入程序，单步步入后，如箭头所示发现ESP寄存器变红。</p><p><img src="https://pic4.zhimg.com/80/v2-5b9a5d2b7381f392b429317ccac2ea7b_720w.jpg" alt="img"></p><p>此时单击右键选中该寄存器进行<strong><em>数据窗口跟随\</em></strong>。然后选中数据窗口任意字符下硬件断点（byte，word，dword均可）。</p><p><img src="https://pic2.zhimg.com/80/v2-8fdadbfa403cb6013789d647edb40e65_720w.jpg" alt="img"></p><p>f9运行后，f8连续单步步过找到OEP（ 程序的入口点 ）。选中该地址单击右键选中用OllyDump脱壳调试进程，然后进行脱壳（如果发现程序不能打开，可以试试勾选重建输入表）。</p><p><img src="https://pic2.zhimg.com/80/v2-d3fd3eaa63382d8ce89dcdd0ed07746d_720w.jpg" alt="img"></p><p>接着用Exeinfo Pe查壳，壳已经被去掉了。</p><p><img src="https://pic4.zhimg.com/80/v2-e4b2d55691152e677f545ed75a3157e3_720w.jpg" alt="img"></p><h2 id="0x03-原理详解"><a href="#0x03-原理详解" class="headerlink" title="0x03 原理详解"></a>0x03 原理详解</h2><p>首先，壳实质上是一个子程序，它在程序运行时首先取得控制权并对程序进行压缩。 同时隐藏程序真正的OEP。大多数病毒就是基于此原理，从而防止被杀毒软件扫描。</p><p>壳的类型：</p><pre class="line-numbers language-text"><code class="language-text">• 解压->运行• 解压->运行->解压.->运行• 解压 decoder|encoded code->decode ->exc• Run the virtual machine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而脱壳的目的就是找到真正的OEP（入口点）。</p><p>而我们所讲到的ESP定律的本质是堆栈平衡，具体如下：</p><p>让我们看下加了壳的这个小程序的入口的各个寄存器的情况</p><pre class="line-numbers language-text"><code class="language-text">EAX 00000000ECX 004E820D offset r1.<ModuleEntryPoint>EDX 004E820D offset r1.<ModuleEntryPoint>EBX 0036C000ESP 0072FF74EBP 0072FF80ESI 004E820D offset r1.<ModuleEntryPoint>EDI 004E820D offset r1.<ModuleEntryPoint>EIP 004E820D r1.<ModuleEntryPoint><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是到OEP时各寄存器的情况</p><pre class="line-numbers language-text"><code class="language-text">EAX 0072FFCCECX 004E820D offset r1.<ModuleEntryPoint>EDX 004E820D offset r1.<ModuleEntryPoint>EBX 0036A000ESP 0072FF74EBP 0072FF80ESI 004E820D offset r1.<ModuleEntryPoint>EDI 004E820D offset r1.<ModuleEntryPoint>EIP 00401500 r1.00401500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现只有EIP和EAX寄存器的数值发生了变化，而EAX保存的是OEP的地址，这是什么原因呢？</p><blockquote><p>由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用<code>pushad</code>, 而在解压结束后, 会将之前的寄存器值出栈, 如使用<code>popad</code>. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置.</p></blockquote><h2 id="0x04-适用范围"><a href="#0x04-适用范围" class="headerlink" title="0x04 适用范围"></a>0x04 适用范围</h2><p>我自己总结了一个比较小白的方法，那就是载入程序后只有esp寄存器内容发生变化，那么这个程序多半可以用ESP定律（如有错误多谢指正）。</p><p>几乎全部的压缩壳， 一些早期的加密壳 （这是在网上收集到的资料总结的，经过我自己的实践，基本准确）。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion中文乱码问题解决</title>
      <link href="/2020/04/10/clion-zhong-wen-luan-ma-wen-ti-jie-jue/"/>
      <url>/2020/04/10/clion-zhong-wen-luan-ma-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<h1 id="解决Windows平台的Clion控制台乱码问题"><a href="#解决Windows平台的Clion控制台乱码问题" class="headerlink" title="解决Windows平台的Clion控制台乱码问题"></a>解决Windows平台的Clion控制台乱码问题</h1><p>最近下载了入了jetbrains全家桶，下载了clion，但是发现clion的控制台中文乱码，刚开始不以为意，去设置里全部修改为UTF-8编码，结果运行的时候还是中文乱码。更古怪的是这时候调试的控制台却并没有中文乱码。<br>然后我从网上开始查阅资料，大部分解决方法都是将控制台的编码改为GNK，我实验了一下，发现确实运行时乱码正常了，但是GBK在调试时又会乱码。<br>本就对这种解决方法抱有怀疑的我觉得这并不是合适的解决方法。<br>然后又看了一些奇怪的解决方法，也没有奏效的。但也有点收获，例如Win10系统本身是GBK编码的，因此好像会产生一些奇怪的冲突，但我又不想改变Win10的编码方式。<br>最后，我找到一篇较为有用的资料，目前JetBrains全家桶只有Clion和Pycharm还在用一种虚拟还是模拟控制台啥的。。记不清了。<br>因为我在用mingw64,所以产生了一些小问题，只要安装cygwin，在设置里添加cygwin并设为默认就没有中文乱码的问题了。</p><blockquote><p>更新：由于cygwin在windows下体验并不好，还是改编码格式吧，只是稍微麻烦点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF分析流程</title>
      <link href="/2020/04/04/ctf-fen-xi-liu-cheng/"/>
      <url>/2020/04/04/ctf-fen-xi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF中逆向的分析思路"><a href="#CTF中逆向的分析思路" class="headerlink" title="CTF中逆向的分析思路"></a>CTF中逆向的分析思路</h1><h2 id="0x00-判断文件类型"><a href="#0x00-判断文件类型" class="headerlink" title="0x00 判断文件类型"></a>0x00 判断文件类型</h2><p>我们拿到的题目一般是一个二进制可执行文件，而其中的大部分不是Windows平台下的PE文件就是Linux平台下的ELF文件。</p><p>不管题目中所给文件带有什么扩展名，我们都应该亲自去检查文件头，使用任意文本编辑工具打开这个二进制文件，如果在开头看到MZ字样，那基本上可以确定这是一个Win系统下的可执行文件。相应的如果看到ELF字样即可基本断定这是一个运行于Linux系统下的可执行文件，扩展名为exe而实质上是一个ELF文件，这种情况在以往的CTF比赛中也是出现过的。</p><p><img src="01.png" alt=""></p><h2 id="0x01-查壳与脱壳"><a href="#0x01-查壳与脱壳" class="headerlink" title="0x01 查壳与脱壳"></a>0x01 查壳与脱壳</h2><p>由于近年来CTF比赛中带壳的逆向题出现频率稍有增加，在静态分析之前，进行查壳是非常有必要的，常用的工具有PEID等，进行查壳后，如果是简单且常见的壳如UPX等，那么直接可以使用工具完成脱壳，如果一时半会找不到可用的工具，也可以尝试手工脱壳，例如ASPack就能够采用ESP定律来脱除。如果是侧重考察脱壳的题，一般程序本身就比较简单了，可以这样说，这类题如果能成功脱壳，基本上也算是做出来了。当然，脱壳并不能解决所有问题，之前有CTF比赛中甚至出现了VMP的题目，对于这种情况，还是建议使用调试器去动态调试，毕竟在逆向工程中太依赖IDA的F5功能也是不行的，还是应该锻炼自己的汇编指令阅读能力。如果是VMP比较新的版本，可能还需要使用Sharp OD等插件来隐藏调试行为。</p><p><img src="02.png" alt=""></p><h2 id="0x02-静态分析"><a href="#0x02-静态分析" class="headerlink" title="0x02 静态分析"></a>0x02 静态分析</h2><p>一般是直接将二进制文件拖入IDA进行分析，在这个过程中，可以关注一下是否有符号库路径的提示出现，如果有这种情况，说明程序在编译阶段并没有清除相应的符号信息，我们或许能够从符号库路径的命名中得知一些关于本题的重要信息，大多数时候，静态分析完成后，我们会直接来到程序start处，直接F5，向下找即可来到main函数，直接查看反编译出来的C伪码，然而有时候IDA会出现识别不了函数的情况，比如说分析到某一段代码，视图就从C伪码变为汇编指令视图了，这时候可以尝试手工地在这段汇编指令中识别出函数，并且使用IDA的创建函数功能，这样一来就能够继续查看C伪码，提高我们的做题效率</p><h2 id="0x03动态调试"><a href="#0x03动态调试" class="headerlink" title="0x03动态调试"></a>0x03动态调试</h2><p>一般是直接将二进制文件拖入OD进行分析, 根据上面的IDA设置断点调试等</p><p><img src="03.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脱壳的常用方法</title>
      <link href="/2020/04/04/tuo-ke-de-chang-yong-fang-fa/"/>
      <url>/2020/04/04/tuo-ke-de-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="脱壳的常用方法"><a href="#脱壳的常用方法" class="headerlink" title="脱壳的常用方法"></a>脱壳的常用方法</h1><h2 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h2><p>  大家应该先明白“壳”的概念。在自然界中，我想大家对”壳”这东西应该都不会陌生了，植物用它来保护种子，动物用它来保护身体等等。同样，在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然（当然后来也出现了所谓的“壳中带籽”的壳）。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”了。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。</p><hr><h2 id="壳的作用"><a href="#壳的作用" class="headerlink" title="壳的作用"></a>壳的作用</h2><p>1 写好一个程序后，不想让别人随便更改其中的版权信息，我们可以加壳对其进行保护防止被修改。</p><ul><li>加密壳</li></ul><p>2 可以利用压缩壳减少程序容量，方便程序传播。</p><ul><li>压缩壳</li></ul><p>3 帮助木马病毒进行免杀，我们可以直接加壳免杀，也可以<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.52pojie.cn%2Fforum-5-1.html" target="_blank" rel="noopener">脱壳</a>对其代码进行修改从而躲过杀毒软件的查杀。</p><ul><li>病毒壳</li></ul><hr><h2 id="脱壳的基础知识"><a href="#脱壳的基础知识" class="headerlink" title="脱壳的基础知识"></a>脱壳的基础知识</h2><h3 id="1壳是怎么装载的？"><a href="#1壳是怎么装载的？" class="headerlink" title="1壳是怎么装载的？"></a>1壳是怎么装载的？</h3><p>  壳自从加到程序上以后就连在一起了，即对程序进行保护，防止被修改，也就是壳把程序给包裹起来了，而且原程序的数据也被压缩了。  </p><p>  装载的时候通常是先执行壳后再跳到真正的原程序OEP（程序入口点），这时开始运行原先没加壳的程序。运行顺序：执行带壳文件——执行壳——执行到程序入口点——运行未加壳的程序。</p><h3 id="2-壳的分类"><a href="#2-壳的分类" class="headerlink" title="2 壳的分类"></a>2 壳的分类</h3><p>  壳出于程序作者想对程序资源压缩、注册保护的目的，壳一般分为压缩壳和加密壳两类。</p><p>​     压缩壳：一般只对文件进行压缩处理，既压缩区段和一些资源压缩，以减少文件体积为目的如：ASPack、UPX、PECompact等</p><p>​     加密壳：跟压缩壳正好相反，一般是牺牲减少体积为代价，对文件进行加密处理，用上各种反跟踪技术保护程序不被调试、脱壳，如：ASProtect、Armadillo、EXECryptor等</p><p>但随着加壳技术的发展，这两类壳之间的界限越来越模糊，很多加壳软件既有压缩功能也有保护性能，而且现在很多加密壳达到壳中带肉，肉中带壳的地步了。 </p><h3 id="3-OEP-（程序入口点）"><a href="#3-OEP-（程序入口点）" class="headerlink" title="3 OEP （程序入口点）"></a>3 OEP （程序入口点）</h3><p>OEP：Original Entry Point ，程序加壳前真正的入口点。 </p><h3 id="4-脱壳的基本步骤"><a href="#4-脱壳的基本步骤" class="headerlink" title="4 脱壳的基本步骤"></a>4 脱壳的基本步骤</h3><p>查壳(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.52pojie.cn%2Fthread-12865-1-1.html" target="_blank" rel="noopener">PEID</a>、FI、PE-SCAN)—&gt;寻找OEP(OD)—&gt;脱壳/Dump(LordPE、PeDumper、OD自带的脱壳插件、PETools)—&gt;修复(Import REConstructor)</p><hr><p><img src="06.png" alt=""></p><h3 id="0x01-查壳"><a href="#0x01-查壳" class="headerlink" title="0x01 查壳"></a>0x01 查壳</h3><p>由于近年来CTF比赛中带壳的逆向题出现频率稍有增加，在静态分析之前，进行查壳是非常有必要的，常用的工具有PEID等，</p><p><img src="02.png" alt=""></p><p>进行查壳后，如果是简单且常见的壳如UPX等，那么直接可以使用工具完成脱壳，</p><p><img src="06.png" alt="">如果一时半会找不到可用的工具，也可以尝试手工脱壳，例如ASPack工具压缩的壳就能够采用ESP定律来脱除。如果是侧重考察脱壳的题，一般程序本身就比较简单了，可以这样说，这类题如果能成功脱壳，基本上也算是做出来了。当然，脱壳并不能解决所有问题，之前有CTF比赛中甚至出现了VMP的题目，</p><ul><li>与其它大部分的保护程序不同，VMProtect可修改程序的源代码 。VMProtect可将被保护文件中的部分代码转化到在虚拟机（以下称作VM）上运行的程序（以下称作bytecode）中。您同样可把VM想象为具备命令系统的虚拟处理器，该命令系统与Intel 8086处理器所使用的完全不同。</li></ul><p>对于这种情况，还是建议使用调试器去动态调试，毕竟在逆向工程中太依赖IDA的F5功能也是不行的，还是应该锻炼自己的汇编指令阅读能力。如果是VMP比较新的版本，可能还需要使用Sharp OD等插件来隐藏调试行为。</p><h2 id="常用脱壳方法"><a href="#常用脱壳方法" class="headerlink" title="常用脱壳方法"></a>常用脱壳方法</h2><h3 id="1-单步跟踪法"><a href="#1-单步跟踪法" class="headerlink" title="1 单步跟踪法"></a>1 单步跟踪法</h3><p>（1）用OD载入，点“不分析代码”</p><p>（2）单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现（通过F4）</p><p>（3）遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点——&gt;运行到所选）</p><p>（4）绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现</p><p>（5）如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑 飞，这样很快就能到程序的OEP</p><p>（6）在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入</p><p>（7）一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN 的一般很快就会到程序的OEP</p><p>注：在有些壳无法向下跟踪的时候，我们可以在附近找到没有实现的大跳转，右键–&gt;“跟随”,然后F2下断，Shift+F9运行停在“跟随”的位置，再取消断点，继续F8单步跟踪。一般情况下可以轻松到达OEP </p><h3 id="2-ESP定律法"><a href="#2-ESP定律法" class="headerlink" title="2 ESP定律法"></a>2 ESP定律法</h3><p>ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）</p><p>（1）开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）（这只是一 般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）</p><p>（2）在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)， 按回车</p><p>（3）选中下断的地址，断点—&gt;硬件访—&gt;WORD断点</p><p>（4）按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP </p><h3 id="3内存镜像法"><a href="#3内存镜像法" class="headerlink" title="3内存镜像法"></a>3内存镜像法</h3><p>（1）用OD打开软件</p><p>（2）点击选项——调试选项——异常，把里面的忽略全部√上。CTRL+F2重载下程序</p><p>（3）按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运 行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的.CODE（也 就是00401000处），按F2下断点。然后按SHIFT+F9（或者是在没异常情况下按F9）， 直接到达程序OEP </p><h3 id="4-一步到达OEP"><a href="#4-一步到达OEP" class="headerlink" title="4 一步到达OEP"></a>4 一步到达OEP</h3><p>（1）开始按Ctrl+F,输入：popad（只适合少数壳，包括UPX，ASPACK壳），然后按下F2， F9运行到此处</p><p>（2）来到大跳转处，点下F8，到达OEP </p><h3 id="5-最后一次异常法"><a href="#5-最后一次异常法" class="headerlink" title="5 最后一次异常法"></a>5 最后一次异常法</h3><p>（1）用OD打开软件</p><p>（2）点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序</p><p>（3）一开始程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按SHIFT+F9到程序运行的次数m</p><p>（4）CTRL+F2重载程序，按SHIFT+F9（这次按的次数为程序运行的次数m-1次）</p><p>（5）在OD的右下角我们看见有一个”SE 句柄”，这时我们按CTRL+G，输入SE 句柄前的地址</p><p>（6）按F2下断点，然后按SHIFT+F9来到断点处</p><p>（7）去掉断点，按F8慢慢向下走</p><p>（8）到达程序的OEP </p><h3 id="6-模拟跟踪法"><a href="#6-模拟跟踪法" class="headerlink" title="6 模拟跟踪法"></a>6 模拟跟踪法</h3><p>（1）先试运行，跟踪一下程序，看有没有SEH暗桩之类</p><p>（2）ALT+M打开内存镜像，找到（包含那一列中出现SFX,imports,relocations或者SFX,输 入表，重定位）</p><p>（3）若地址为00xxxxxx在命令行下输入tc eip&lt;00xxxxxx，回车，提示正在跟踪</p><h3 id="7-SFX法"><a href="#7-SFX法" class="headerlink" title="7 SFX法"></a>7 SFX法</h3><p>（1）设置OD，忽略所有异常，也就是说异常选项卡里面都打上勾</p><p>（2）切换到SFX选项卡，选择“字节模式跟踪实际入口（速度非常慢）”，确定</p><p>（3）重载程序（如果跳出是否“压缩代码？”选择“否”，OD直接到达OEP）</p><h2 id="ESP定律法"><a href="#ESP定律法" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><ul><li>ESP定律法是脱壳的利器，是应用频率最高的脱壳方法之一。</li><li>原理：ESP定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。</li><li>PUSHAD指令压入32位寄存器，其入栈顺是:EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI .即把所有的寄存器都压栈。</li><li>“堆栈平衡”原理：call命令是访问子程序的一个汇编基本指令，它先向堆栈中压入下一行程序的地址，再JMP到call的子程序地址处。与call对应的就是RETN，将当前的ESP中指向的地址出栈；JMP到这个地址。这里有一个前提：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。Call和retn的时候地址是对应的，这就是“堆栈平衡”。<br>＃＃＃ｅｓｐ定律适用范围：几乎全部的压缩壳,部分加密壳。</li></ul><h3 id="脱壳步骤："><a href="#脱壳步骤：" class="headerlink" title="脱壳步骤："></a>脱壳步骤：</h3><ul><li>1、单步运行，右侧寄存器ESP为红色，说明esp值改变。当前ESP为pushad压栈当前所有寄存器以后的栈顶位置。根据“堆栈平衡”原理。脱壳以后，还会在这个位置出栈。<br><img src="11.png" alt="img"></li><li>脱壳前寄存器值：</li></ul><p><img src="12.png" alt="img"></p><ul><li>2、所以，我们右键esp，选择在数据窗口跟随</li></ul><p><img src="13.png" alt="img"></p><ul><li>3、在数据窗口，我们选一个位置,右键“断点”-&gt;“硬件访问”-&gt;“Byte”设置硬件断点，然后“调试”-&gt;“硬件断点”，查看断点。</li><li>为什么要在这里设置断点(⊙o⊙)?因为我们可以把壳看成一个子程序，解压缩或者解密完了，它要把控制权交还给主程序。一开始pushad入栈，返回程序本身的时候要在同样的位置出栈，ESP是栈顶指针，出栈时栈顶指针和入栈时相同，而出栈时，壳的部分运行完成了，也就到了OPE附近。</li></ul><p><img src="14.png" alt="img"></p><ul><li>4、运行程序到断点处，删除断点。删除断点是因为如果硬件断点一直存在，那么程序一直跑就有可能一直断下来，很不方便。根据ESP定律，程序入口在断点附近。</li></ul><p><img src="15.png" alt="img"></p><ul><li><p>此时的寄存器，可以看到，除了EIP，其他和pushad时完全一样。<br><img src="16.png" alt="img"></p></li><li><p>5、单步运行，找到OPE<br><img src="17.png" alt="img"></p></li><li><p>6、用OllyDumpEx脱壳</p><p><img src="04.png" alt=""></p></li></ul><h2 id="一步直达法"><a href="#一步直达法" class="headerlink" title="一步直达法"></a>一步直达法</h2><ul><li>这个非常简单，但是有适用范围，适用于USP和aspack</li><li>原理：开头有pushad入栈，那么一定会有popad出栈，出栈时就说解压缩完成后，到达了OPE附近。</li><li>步骤：</li><li>直接搜索ＰＯＰＡＤ，然后Ｆ４，运行到ＰＯＰＡＤ</li><li>然后F2，F9执行到这里，来到大跳转处，到达OEP </li><li>即可找到ＯＰＥ<br><img src="18.png" alt="img"></li></ul><p>－　注意：不要勾选整个块</p><p>－　如图，ｊｕｍｐ过去以后就是ＯＰＥ<br><img src="19.png" alt="img"></p><h2 id="内存镜像法"><a href="#内存镜像法" class="headerlink" title="内存镜像法"></a>内存镜像法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>依次选择OD选项（T）下的调试设置（D）子选择，弹出如下对话框，切到异常选项卡，将忽略下的子项全部勾上</p><p><img src="05.png" alt=""></p></li></ul><ul><li>1、Alt+M查看内存<br><img src="20.png" alt="img"></li><li>2、找到程序段的第一个.rsrc ,设置中断访问并运行。<br><img src="21.png" alt="img"></li><li>3、再设一次断点，运行<br><img src="22.png" alt="img"></li><li>4、单步运行，又到了popad<br><img src="23.png" alt="img"></li><li>5、找到OPE，脱壳<br><img src="24.png" alt="img"></li></ul><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p><img src="25.png" alt="img"></p><ul><li>问题：出错，第二次设断运行后，没有删除内存断点，再单步时出错。</li><li>解决：出错是因为没有删除访问中断，删除访问中断就可以了。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>断点：让程序在运行时暂停到特定的代码段，下断点是调试器的功能之一，可以让程序中断在需要的地方，从而方便其分析。</li><li>常用的断点包括：INT3断点、硬件断点、内存断点、消息断点、条件断点等。</li><li>内存访问断点分为，内存访问断点和内存写入断点。</li><li>内存访问：代码段的代码访问内存数据。</li><li>内存写入：代码段的代码执行完成后把数据写入内存</li><li>内存访问断点：代码段的代码访问内存数据的时候，程序暂停。</li><li>内存写入断点：代码段的代码写入内存数据的时候，程序暂停。</li><li>如果给内存设内存访问断点，那么，程序就会在读取该内存数据的代码上中断。</li><li>比如：<img src="26.png" alt="img"><br>寄存器间接寻址，操作数在以该寄存器中的内容为偏移地址的内存单元中，把以“ecx”值为地址的内存单元的值赋予dl，如果在地址为“ecx”值的内存下断点，那么，程序运行到这一条指令时就会中断。</li><li>壳在解压缩时，需要在内存读取压缩过的源代码，进行解压缩，然后再进行内存写入。</li><li>第一次内存断点设在资源段，假设解压顺序是先代码段，数据段，再资源段，那么。资源段发生写入中断时，程序就已经完成了代码段和数据段的解压。然后，我们在解压完成的基础上，在代码段下第二个断点，程序再次中断时，就运行到了代码段的OPE附近。</li><li>在第二次中断后，经过几次单步运行即可到达OPE。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圈小猫游戏</title>
      <link href="/2020/03/24/quan-xiao-mao-you-xi/"/>
      <url>/2020/03/24/quan-xiao-mao-you-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="最近发现一个H5的小游戏，挺有趣的"><a href="#最近发现一个H5的小游戏，挺有趣的" class="headerlink" title="最近发现一个H5的小游戏，挺有趣的"></a>最近发现一个H5的小游戏，挺有趣的</h1><h1 id="点击此处玩游戏哦"><a href="#点击此处玩游戏哦" class="headerlink" title="点击此处玩游戏哦"></a><a href="https://amarantos.gitee.io/catch-the-cat" target="_blank" rel="noopener">点击此处玩游戏哦</a></h1><a id="more"></a><p><img src="catch-cat.png" alt="圈小猫游戏"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF学习笔记</title>
      <link href="/2020/03/24/ctf-xue-xi-bi-ji/"/>
      <url>/2020/03/24/ctf-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF学习笔记"><a href="#CTF学习笔记" class="headerlink" title="CTF学习笔记"></a>CTF学习笔记</h1><p><del>刚买完xbox的手柄。。。内心十分罪恶。</del>于是我终于决定狠下心来好好学习一下CTF，目前的打算是学习reverse逆向。。。<del>感觉前路困难重重，这个学习笔记随时停更，甚至搁浅</del><br><strong><em><del>目前从入门到放弃</del>学习进程：1.0%</em></strong></p><h2 id="先简单介绍下CTF-复制的"><a href="#先简单介绍下CTF-复制的" class="headerlink" title="先简单介绍下CTF(复制的)"></a>先简单介绍下CTF(复制的)</h2><h3 id="CTF的起源"><a href="#CTF的起源" class="headerlink" title="CTF的起源"></a>CTF的起源</h3><p><strong>CTF</strong>（Capture The Flag，夺旗赛）起源于 1996 年 <strong>DEFCON</strong> 全球黑客大会，是网络安全爱好者之间的竞技游戏。</p><h3 id="早期-CTF-竞赛"><a href="#早期-CTF-竞赛" class="headerlink" title="早期 CTF 竞赛"></a>早期 CTF 竞赛</h3><p>第一个 CTF 比赛（1996 年 - 2001 年），没有明确的比赛规则，没有专业搭建的比赛平台与环境。由参数队伍各自准备比赛目标（自行准备与防守比赛目标，并要尝试攻破对方的比赛目标）。而组织者大都只是一些非专业的志愿者，接受参赛队伍手工计分的请求。</p><p>没有后台自动系统支持和裁判技术能力认定，计分延迟和误差以及不可靠的网络和不当的配置，导致比赛带来了极大的争论与不满。</p><h3 id="「现代」CTF-竞赛"><a href="#「现代」CTF-竞赛" class="headerlink" title="「现代」CTF 竞赛"></a>「现代」CTF 竞赛</h3><p>由专业队伍承担比赛平台、命题、赛事组织以及自动化积分系统。参赛队伍需提交参赛申请，由 DEFCON 会议组织者们进行评选。</p><p>就 LegitBS 组织的三年 DEFCON CTF 比赛而言，有以下突出特点：</p><ul><li><p>比赛侧重于对计算机底层和系统安全的核心能力，Web 漏洞攻防技巧完全被忽略。</p></li><li><p>竞赛环境趋向多 CPU 指令架构集，多操作系统，多编程语言。</p></li><li><p>采用「零和」计分规则。</p></li><li><p>团队综合能力考验：逆向分析、漏洞挖掘、漏洞利用、漏洞修补加固、网络流量分析、系统安全运行维护以及安全方面的编程调试。</p><a id="more"></a><h2 id="CTF-Contest-Content-复制的"><a href="#CTF-Contest-Content-复制的" class="headerlink" title="CTF Contest Content(复制的)"></a>CTF Contest Content(复制的)</h2><p>由于 CTF 的考题范围其实比较宽广，目前也没有太明确的规定界限说会考哪些内容。但是就目前的比赛题型而言的话，主要还是依据常见的 <strong>Web 网络攻防、RE 逆向工程、Pwn 二进制漏洞利用、Crypto 密码攻击、Mobile 移动安全</strong> 以及 <strong>Misc 安全杂项</strong> 来进行分类。</p></li><li><p><strong>Web - 网络攻防</strong><br>主要介绍了 Web 安全中常见的漏洞，如 SQL 注入、XSS、CSRF、文件包含、文件上传、代码审计、PHP 弱类型等，Web 安全中常见的题型及解题思路，并提供了一些常用的工具。</p></li><li><p><strong>Reverse Engineering - 逆向工程</strong><br>主要介绍了逆向工程中的常见题型、工具平台、解题思路，进阶部分介绍了逆向工程中常见的软件保护、反编译、反调试、加壳脱壳技术。</p></li><li><p><strong>Pwn - 二进制漏洞利用</strong><br>Pwn 题目主要考察二进制漏洞的发掘和利用，需要对计算机操作系统底层有一定的了解。在 CTF 竞赛中，PWN 题目主要出现在 Linux 平台上。</p></li><li><p><strong>Crypto - 密码攻击</strong><br>主要包括古典密码学和现代密码学两部分内容，古典密码学趣味性强，种类繁多，现代密码学安全性高，对算法理解的要求较高。</p></li><li><p><strong>Mobile - 移动安全</strong><br>主要介绍了安卓逆向中的常用工具和主要问题类型，安卓逆向常常需要一定的安卓开发知识，iOS 逆向题目在 CTF 竞赛中较少出现，因此不作过多介绍。</p></li><li><p><strong>Misc - 安全杂项</strong><br>以诸葛建伟翻译的《线上幽灵：世界头号黑客米特尼克自传》和一些典型 MISC 题为切入点，内容主要包括信息搜集、编码分析、取证分析、隐写分析等。</p></li></ul><h2 id="全国大学生信息安全竞赛-竞赛内容"><a href="#全国大学生信息安全竞赛-竞赛内容" class="headerlink" title="全国大学生信息安全竞赛 - 竞赛内容"></a>全国大学生信息安全竞赛 - 竞赛内容</h2><p>2016 年全国大学生信息安全竞赛开始举办创新实践技能赛，采取的就是传统的 CTF 赛制。在《2016 年全国大学生信息安全竞赛参赛指南》中主办方给出的竞赛内容相对全面，值得参考。</p><ul><li><p>系统安全。涉及操作系统和 Web 系统安全，包括 Web 网站多种语言源代码审计分析（特别是 PHP）、数据库管理和 SQL 操作、Web 漏洞挖掘和利用（如 SQL 注入和 XSS）、服务器提权、编写代码补丁并修复网站漏洞等安全技能。</p></li><li><p>软件逆向。涉及 Windows/Linux/Android 平台的多种编程技术，要求利用常用工具对源代码及二进制文件进行逆向分析，掌握 Android 移动应用 APK 文件的逆向分析，掌握加解密、内核编程、算法、反调试和代码混淆技术。</p></li><li><p>漏洞挖掘和利用。掌握 C/C++/Python/PHP/Java/Ruby / 汇编 等语言，挖掘 Windows/Linux（x86/x86＿64 平台）二进制程序漏洞，掌握缓冲区溢出和格式化字符串攻击，编写并利用 shellcode。</p></li><li><p>密码学原理及应用。掌握古典密码学和现代密码学，分析密码算法和协议，计算密钥和进行加解密操作。</p></li><li><p>其他内容。包括信息搜集能力，编程能力、移动安全、云端计算安全、可信计算、自主可控、隐写术和信息隐藏、计算机取证（Forensics）技术和文件恢复技能，计算机网络基础以及对网络流量的分析能力。</p></li></ul><h2 id="Learning-Resources"><a href="#Learning-Resources" class="headerlink" title="Learning Resources"></a>Learning Resources</h2><h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><ul><li><a href="http://www.ichunqiu.com/" target="_blank" rel="noopener">i 春秋 - 专业的网络安全 | 信息安全在线学习培训平台</a></li><li><a href="http://www.shiyanbar.com/" target="_blank" rel="noopener">实验吧－让实验更简单！</a></li><li><a href="https://www.kanxue.com/chm.htm" target="_blank" rel="noopener">看雪知识库</a><h3 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h3></li><li><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/index.html" target="_blank" rel="noopener">知道创宇研发技能表 v3.1</a></li><li><a href="https://skills.bugbank.cn/" target="_blank" rel="noopener">漏洞银行 (BUGBANK) 技能树</a></li><li><a href="http://evilcos.me/security_skill_tree_basic/index.html" target="_blank" rel="noopener">安全技能树简版 by 余弦</a></li><li><a href="https://github.com/phith0n/Mind-Map" target="_blank" rel="noopener">安全类思维导图 by phith0n</a></li><li><a href="https://github.com/riusksk/secbook" target="_blank" rel="noopener">信息安全从业者书单推荐</a><h3 id="信息资讯"><a href="#信息资讯" class="headerlink" title="信息资讯"></a>信息资讯</h3></li><li><a href="http://www.freebuf.com/" target="_blank" rel="noopener">FreeBuf.COM | 关注黑客与极客</a></li><li><a href="https://www.anquanke.com/" target="_blank" rel="noopener">安全客 - 有思想的安全新媒体</a></li><li><a href="http://www.4hou.com/" target="_blank" rel="noopener">嘶吼 RoarTalk – 回归最本质的信息安全</a></li><li><a href="https://wiki.ioin.in/" target="_blank" rel="noopener">Sec-News 安全文摘</a><h3 id="技术论坛"><a href="#技术论坛" class="headerlink" title="技术论坛"></a>技术论坛</h3></li><li><a href="http://www.52pojie.cn/" target="_blank" rel="noopener">吾爱破解</a></li><li><a href="http://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a></li><li><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">先知社区</a></li><li><a href="https://bbs.ichunqiu.com/" target="_blank" rel="noopener">i 春秋论坛</a><h3 id="CTF-赛事"><a href="#CTF-赛事" class="headerlink" title="CTF 赛事"></a>CTF 赛事</h3></li><li><a href="https://www.xctf.org.cn/" target="_blank" rel="noopener">XCTF 社区</a></li><li><a href="https://ctftime.org/" target="_blank" rel="noopener">CTFtime</a></li><li><a href="https://ctfrank.org/" target="_blank" rel="noopener">CTF Rank</a><h3 id="CTF-OJ"><a href="#CTF-OJ" class="headerlink" title="CTF OJ"></a>CTF OJ</h3></li><li><a href="http://oj.xctf.org.cn/" target="_blank" rel="noopener">XCTF OJ</a></li><li><a href="https://www.ichunqiu.com/competition" target="_blank" rel="noopener">CTF 大本营</a></li><li><a href="https://pwnhub.cn/index" target="_blank" rel="noopener">pwnhub</a></li><li><a href="http://ctf.nuptsast.com/" target="_blank" rel="noopener">南邮网络攻防训练平台</a></li><li><a href="http://hackinglab.cn/" target="_blank" rel="noopener">HackingLab 网络信息安全攻防学习平台</a></li><li><a href="http://ctf.bugku.com/" target="_blank" rel="noopener">BugkuCTF</a></li><li><a href="https://www.wechall.net/" target="_blank" rel="noopener">WeChall</a></li><li><a href="http://www.sniperoj.com/" target="_blank" rel="noopener">Sniper OJ</a></li><li><a href="https://www.jarvisoj.com/" target="_blank" rel="noopener">Jarvis OJ</a></li><li><a href="https://ctflearn.com/" target="_blank" rel="noopener">CTF Learn</a></li><li><a href="https://hackme.inndy.tw/scoreboard/" target="_blank" rel="noopener">Hackme CTF</a></li><li><a href="http://captf.com/practice-ctf/" target="_blank" rel="noopener">Practice CTF List</a><h3 id="CTF-工具"><a href="#CTF-工具" class="headerlink" title="CTF 工具"></a>CTF 工具</h3></li><li><a href="https://tools.pediy.com/" target="_blank" rel="noopener">看雪工具</a></li><li><a href="https://down.52pojie.cn/Tools/" target="_blank" rel="noopener">吾爱破解工具</a></li><li><a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">CTF 在线工具 by CTFcode</a></li><li><a href="http://tool.bugku.com/" target="_blank" rel="noopener">CTF 在线工具箱 by bugku</a></li><li><a href="https://ctftools.com/down/" target="_blank" rel="noopener">CTF 工具资源库 by HBCTF team</a></li><li><a href="https://github.com/zardus/ctf-tools" target="_blank" rel="noopener">ctf-tools by zardus</a></li><li><a href="https://gchq.github.io/CyberChef/" target="_blank" rel="noopener">The Cyber Swiss Army Knife</a><h3 id="CTF-Writeup-集合"><a href="#CTF-Writeup-集合" class="headerlink" title="CTF Writeup 集合"></a>CTF Writeup 集合</h3></li><li><a href="https://github.com/ctfs" target="_blank" rel="noopener">CTFs Writeup 集锦</a></li><li><a href="https://github.com/p4-team/ctf" target="_blank" rel="noopener">CTF solution by p4 team</a></li></ul><h1 id="正式进入Reverse学习"><a href="#正式进入Reverse学习" class="headerlink" title="正式进入Reverse学习"></a>正式进入Reverse学习</h1><p>等我入门了再填坑，这篇博客先停一段时间，最近作业好多。。。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D加密</title>
      <link href="/2020/02/26/d-jia-mi/"/>
      <url>/2020/02/26/d-jia-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="D加密"><a href="#D加密" class="headerlink" title="D加密"></a>D加密</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Denuvo全称Denuvo Anti-Tamper（反篡改），一种Windows平台上能阻止对可执行文件进行调试(Debugging)、反向工程(Reverse Engineering)和修改(Modifying)的技术，由奥地利公司Denuvo软件解决方案有限公司开发。Denuvo本身并不是DRM（数字版权管理系统，如Steam、Uplay和Origin等），而是用来保护游戏的DRM不被绕过的。</p><p>对于其他的加密系统，破解者只需要修改游戏的exe或dll文件绕过游戏对DRM的验证，然后模拟正版环境（如特制的steam_api.dll）即可实现破解。而Denuvo就是用来保护游戏的二进制文件(中和DRM相关的模块)不被调试和修改的，这样破解者就没有办法绕过DRM验证从而实现防止破解。</p><a id="more"></a><p>目前关于Denuvo的具体工作原理，目前除了开发者以外基本上无人知晓其完整的工作方式，我们知道Denuvo反篡改系统会在第一次启动游戏时把PC的硬件和操作系统信息发送至Denuvo的服务器以取得独一无二的认证密钥存储在本地，每次游戏启动时都会检查该密钥是否和当前运行环境匹配，除此之外游戏运行中还会多次进行校验，一旦校验失败游戏就会终止运行或者游戏玩法发生改变。早前，有报道指出，Denuvo程序对其自身持续不断地进行加密并解密来防止被破解，从而会损伤SSD。后来Denuvo的开发公司出来澄清道“我们的反篡改技术没有对存储介质上的数据进行加密或者解密，这样不但不会提高安全性，反而还会拖累性能；不影响游戏性能是客户(指游戏开发商)提出的重要条件一。‘Denuvo会损伤SSD’完全是论坛上某些人脑补出来的”。</p><p>Denuvo的雇员称其保护技术包括反篡改(Anti-Tamper)、反调试(Anti-Debugging)、反载入(Anti-Loader)和篡改检测技术(游戏内的触发器使得破解版游戏的玩法发生改变)，这些保护技术可通过加密引擎自动部署。Denuvo反篡改技术的保护对象主要是Windows平台下C++编写的游戏。</p><h2 id="破解原理"><a href="#破解原理" class="headerlink" title="破解原理"></a>破解原理</h2><p>Denuvo反篡改技术会在游戏内置许多检测游戏是否被篡改的触发器，而这些触发器是基于VMProtect虚拟机的。或许有人听说过VMProtect——很多病毒、木马程序都通过VMProtect进行加壳来逃避杀毒软件基于病毒特征码的检测。同样的原理，想要破解Denuvo游戏，就需要找出其特征码，就像杀毒软件公司分析病毒特征码那般。</p><p>目前为止仍然只有CPY破解组能攻破当前版本的Denuvo反篡改技术，原因只可能是CPY成功找到了Denuvo游戏中大量复杂的触发器的特征码。触发器是埋藏在游戏中任意地方、用于检测游戏是否被篡改的校验模块，上文中有提到，破解者曾尝试暴力找出（即边玩游戏边观察游戏中的触发器）埋藏在游戏内的触发器并一一干掉，但是无奈于这些触发器太多太复杂，手动寻找触发器不仅处理起来极其麻烦，而且还很容易有遗漏的。然而CPY却能在很短的时间内没有遗漏地找到所有触发器并用补丁使其失效，那么说明了CPY掌握到了触发器的特征码并能通过一些辅助调试软件来快速找到这些触发器。 可以想象的到，触发器的特征码一定极其复杂难以被发现，所以只有CPY破解组能成功找到。</p><p>CPY的破解文件（steamapi64.dll）只是把所有的触发器给禁用掉，我们不知道CPY是如何成功找出触发器的，所以对于Denuvo的开发人员来说，他们也不知道CPY掌握到了触发器的哪些特征码，因此CPY的破解方法难以在短时间内修复。这就好比，老师给你出了一道高数大题，然而你只写了最终计算结果，老师看不到你的计算过程、不知道你是如何得出最终答案的。在《古墓丽影：崛起》被破解后，Denuvo的开发者着手尝试修改他们自认为CPY识别出的触发器特征码，然而使用v3版本Denuvo的《看门狗2》被破解的事实证明，这种修补方法并不奏效，CPY依然能继续找出Denuvo触发器的特征码。</p><p>所以，Denuvo公司要想隐藏触发器的特征码，就必须得从底层重写触发器的构造——这就是为什么在2017年新版Denuvo中，触发器所依赖的虚拟机从VMProtect换成了全新的自制虚拟机。而使用v4版本的《质量效应：仙女座》的破解，证明自制虚拟机仍然有破绽。</p><p>参考：</p><ul><li><a href="https://www.ruan8.com/wenda/2322.html" target="_blank" rel="noopener">https://www.ruan8.com/wenda/2322.html</a></li><li><a href="https://www.zhihu.com/question/31592040/answer/81616851" target="_blank" rel="noopener">https://www.zhihu.com/question/31592040/answer/81616851</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的加密算法</title>
      <link href="/2020/02/25/you-xi-zhong-de-jia-mi-suan-fa/"/>
      <url>/2020/02/25/you-xi-zhong-de-jia-mi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏中的加密算法"><a href="#游戏中的加密算法" class="headerlink" title="游戏中的加密算法"></a>游戏中的加密算法</h1><p>加密主要包含通信数据和存储数据加密，目的都是为了保证其传送和储存的隐秘性，从而保证数据的安全。目前常见的加密方式有对称加密、非对称加密、hash加密、hash加盐加密等,这些在游戏中都会用的，我们会对其用途以及缺陷一一说明，当然了，为了保证其加密算法的安全以及高效，我们也会介绍几种自定义的加密算法，看看加密如何来维护我们的数据安全。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密算法是应用较早的加密算法，技术成熟。主要就是对密钥的一个维护，发送方把数据和密钥通过一定的加密算法处理后，发送给接收方，接受方接到之后在使用相同密钥及算法的逆算法对密文进行解密。这就是一般的对称加密算法过程。常见的对称加密算法有AES、DES，3DES，TDEA，Blowfish，RC5，IDEA等，建议用AES,速度快，安全性也可以。</p><p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。缺点主要就是密钥需要双方都有，如果密钥被窃取，那么加密就会比第三方破解，特别是游戏中，密钥如果存放在客户端中，容易被破解反编译到。</p><p>我们可以采取登陆消息和逻辑消息采用不同的密钥，登陆验证通过之后，服务器为每个用户分配不同的密钥，然后把逻辑密钥传送给客户端，以此保证密钥的不确定性，从而增加游戏的安全。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。这对于对称加密算法来说，又安全了一步，也是目前https常用的加密方式，公钥可以分配和暴露给所有想要访问的请求者，但密钥一定牢牢的掌握在服务器这边，如此对通信来说，安全性有保证。常用的加密算法，RSA,DSA,ECC。</p><a id="more"></a><p>非对称加密算法，优点就是安全，但缺点就是不够快，比较耗费cpu，如果在游戏中每一次消息都有其加密，对cpu的损耗还是挺高的，所以游戏中一般不用这种加密方式，当然了也看游戏类型，如果对这方面的性能要求不高，安全性要求有很高，采用业务科厚非（那个游戏这么傻啊）。</p><h2 id="hash加密"><a href="#hash加密" class="headerlink" title="hash加密"></a>hash加密</h2><p>hash加密，就是常见的使用MD5、SHA1等单向HASH算法保护密码，使用这些算法后，无法通过计算还原出原始密码，而且实现比较简单也高效，因此很多互联网公司都采用这种方式保存用户密码。</p><p>但安全性越来越担忧了，因为随着彩虹表技术的兴起，可以建立彩虹表进行查表破解，目前这种方式已经很不安全了。</p><h2 id="hash-加盐加密"><a href="#hash-加盐加密" class="headerlink" title="hash 加盐加密"></a>hash 加盐加密</h2><p>hash加密既然容易被彩虹表破解，那么可以采用加盐、多次HASH等扩展，这样可以在一定程度上增加破解难度。常见的方式也是发送方和接受方，维护一个盐池，加密和解密的时候加上这一段盐池来进行hash。</p><p>不过这种算法又回到了对称加密中对密钥的保护问题了，如果盐池泄露，别人依然会破解。</p><p>怎么办？有人又想出了，让盐池随机的方式，比如PBKDF2算法，原理大致相当于在HASH算法基础上增加随机盐，并进行多次HASH运算，随机盐使得彩虹表的建表难度大幅增加，而多次HASH也使得建表和破解的难度都大幅增加。一次密码验证过程进行1000次HASH运算，对服务器来说可能只需要1ms，但对于破解者来说计算成本增加了1000倍，而至少8字节随机盐，更是把建表难度提升了N个数量级，使得大批量的破解密码几乎不可行，该算法也是美国国家标准与技术研究院推荐使用的算法。</p><h2 id="自定义加密"><a href="#自定义加密" class="headerlink" title="自定义加密"></a>自定义加密</h2><p>终于到这个了，以上那么多高大上的加密算法，都是业界比较成熟的算法，好处是处处有API支持也有人实现，拿来就用，坏处也是，算法格式规整透明，除了非对称算法，都有其对应的破解方式。游戏的加密要怎样？安全、安全，高效、高效，你不能一个加密算法就耗费我100ms的cpu吧，太浪费了。</p><p>我们可以尝试一种动态加密的方式，就是每一次请求保证用不同的密钥，这样即便一个消息被截取破解了，下一次密钥又不一样，如此破解者会比较崩溃。怎么做？我简单说下思想。</p><pre><code>每个消息必须有唯一id，一个是防止消息重放，一个可以用来做我们的加密。比如我们初始的时候有一个密码池 A=【1,2,3,4,5】，每次消息从服务器发送出去的时候，消息ID都+1，当前密钥=A.index(消息ID%A.length)，如此就能保证每次密钥不一样，具体拿到密钥如何加密，完全可以用自己的加密方式，比如把二进制一部分截取通过密钥移位操作，或者算法运算都可以。</code></pre><p>我们的目的一个保证密钥动态，一个就是保证算法足够高效。</p><table><thead><tr><th>算法</th><th>特点</th><th>有效破解方式</th><th>破解难度</th><th>其它</th><th>算法名字</th></tr></thead><tbody><tr><td>对称加密</td><td>可以解密出明文</td><td>获取密钥</td><td>中</td><td>需要确保密钥不泄露</td><td>AES，3DES</td></tr><tr><td>非对称加密</td><td>一对钥匙—<a href="https://baike.baidu.com/item/公钥" target="_blank" rel="noopener">公钥</a>和<a href="https://baike.baidu.com/item/私钥" target="_blank" rel="noopener">私钥</a></td><td>获取私钥</td><td>高</td><td>效率低，安全性高</td><td>RSA,DSA,ECC,DH</td></tr><tr><td>HASH加密</td><td>简单，高效</td><td>碰撞、彩虹表</td><td>中</td><td></td><td>MD5，SHA1，SHA1256</td></tr><tr><td>加盐HASH</td><td>对hash加盐处理</td><td>碰撞、彩虹表</td><td>中</td><td>需要确保“盐”不泄露</td><td>同上</td></tr><tr><td>Pbkdf2</td><td>对hash的盐池进行随机处理</td><td>无</td><td>难</td><td>随机盐池不能太大，8个字节比较合适</td><td>同上</td></tr><tr><td>自定义算法</td><td>非标准，高效，安全</td><td>无</td><td>难</td><td>算法的灵活性</td><td>动态密钥</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻4引擎学习笔记</title>
      <link href="/2020/02/24/xu-huan-4-yin-qing-xue-xi-bi-ji/"/>
      <url>/2020/02/24/xu-huan-4-yin-qing-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="UNREAL-ENGINE"><a href="#UNREAL-ENGINE" class="headerlink" title="UNREAL ENGINE"></a>UNREAL ENGINE</h1><h2 id="入坑简介"><a href="#入坑简介" class="headerlink" title="入坑简介"></a>入坑简介</h2><pre><code>由于我一直对游戏制作很感兴趣，所以去了解了各个游戏引擎，目前主流的大型游戏引擎大概有起源，寒霜3，Unity 3D，虚幻4，Cry Engine 3等。这些引擎中起源2并不开源，寒霜也是EA独家的，在剩下三个中因为UE4的学习资源比较丰富，所以我选择了先去了解这个引擎。</code></pre><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><pre><code>这方面不再赘述，去虚幻4官网先下载Epic，再下载虚幻4引擎即可。</code></pre><h2 id="学习资源来源"><a href="#学习资源来源" class="headerlink" title="学习资源来源"></a>学习资源来源</h2><ul><li><a href="https://docs.unrealengine.com/en-US/index.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.unrealengine.com/zh-CN/onlinelearning-courses" target="_blank" rel="noopener">官方在线学习</a></li><li><a href="https://forums.unrealengine.com/" target="_blank" rel="noopener">官方社区</a></li><li><a href="https://www.bilibili.com/video/av52017180?p=1" target="_blank" rel="noopener">b站一位大佬up主的教学视屏</a></li><li>youtube搜索相关学习资源</li></ul><a id="more"></a><h2 id="正在更新"><a href="#正在更新" class="headerlink" title="正在更新"></a>正在更新</h2>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux平台VS_code的网页打开</title>
      <link href="/2020/02/16/linux-ping-tai-vs-code-de-wang-ye-da-kai/"/>
      <url>/2020/02/16/linux-ping-tai-vs-code-de-wang-ye-da-kai/</url>
      
        <content type="html"><![CDATA[<h1 id="解决VS-code在Linux平台下打开chrome等浏览器的问题"><a href="#解决VS-code在Linux平台下打开chrome等浏览器的问题" class="headerlink" title="解决VS_code在Linux平台下打开chrome等浏览器的问题"></a>解决VS_code在Linux平台下打开chrome等浏览器的问题</h1><p><strong>近期开始自学前端，使用VS_code，发现在Windows下正常使用的插件Opeon in browser等插件在Linux下使用Alt+b无法打开GoogleChrome浏览器调试网页，于是找到以下解决方案。</strong><br>由于在linux平台下chrome浏览器的包名不同，因此open in browser等打开chrome浏览器的插件会报错。<br>解决方法可以通过软链接，使用以下命令：</p><ul><li><p>首先打开终端,输入以下命令获取Chrome浏览器的具体连接地址:</p><pre class="line-numbers language-shell"><code class="language-shell">which google-chrome-stable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><a id="more"></a><p><img src="whereis.png" alt="which google-chrome-stable"></p></li><li><p>复制Chrome路径地址，输入ln命令创建软连接，因为open in browser默认打开为google-chrome 所以创建google-chrome连接:</p><pre class="line-numbers language-shell"><code class="language-shell">sudo ln -s /usr/bin/google-chrome-stable /usr/bin/google-chrome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开VsCode，点击齿轮图标进行设置，搜索open in browser,将Set default browser 为 google-chrome 后重启VsCode即可。<br><img src="setting.png" alt="setting"></p></li></ul><h2 id="更方便的解决方法"><a href="#更方便的解决方法" class="headerlink" title="更方便的解决方法"></a>更方便的解决方法</h2><blockquote><p>建议安装Live Server这个插件，在Linux平台下没有问题，开箱即用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记</title>
      <link href="/2020/02/10/go-yu-yan-xue-xi-bi-ji/"/>
      <url>/2020/02/10/go-yu-yan-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言学习笔记"><a href="#Go语言学习笔记" class="headerlink" title="Go语言学习笔记"></a>Go语言学习笔记</h1><h2 id="Go语言简介"><a href="#Go语言简介" class="headerlink" title="Go语言简介"></a>Go语言简介</h2><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。</p><a id="more"></a><h2 id="Go语言的特性"><a href="#Go语言的特性" class="headerlink" title="Go语言的特性"></a>Go语言的特性</h2><p>Go 语言从本质上（程序和结构方面）来实现并发编程。</p><p>因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。</p><p>在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。</p><p>函数是 Go 语言中的基本构件，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。</p><p>Go 语言使用静态类型，所以它是类型安全的一门语言，加上通过构建到本地代码，程序的执行速度也非常快。</p><p>作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。</p><p>Go 语言其实也有一些动态语言的特性（通过关键字 var），所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。</p><p>Go 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ </p><ul><li>简化问题，易于学习</li><li>内存管理，简洁语法，易于使用</li><li>快速编译，高效开发</li><li>高效执行</li><li>并发支持，轻松驾驭</li><li>静态类型</li><li>标准类库，规范统一</li><li>易于部署</li><li>文档全面</li><li>免费开源</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。目前 gccgo 还没有回收器，同时适用 gc 和 gccgo 的新回收器正在研发中。使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。</p><p>Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总的来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。</p><h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><p>Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。<br><strong><em>在命令行输入<code>gofmt –w program.go</code>会格式化该源文件的代码然后将格式化后的代码覆盖原始内容</em></strong></p><h2 id="与其它语言进行交互（待填坑）"><a href="#与其它语言进行交互（待填坑）" class="headerlink" title="与其它语言进行交互（待填坑）"></a>与其它语言进行交互（待填坑）</h2><h3 id="与C语言交互"><a href="#与C语言交互" class="headerlink" title="与C语言交互"></a>与C语言交互</h3><p>（待填坑）</p><h3 id="与C-交互"><a href="#与C-交互" class="headerlink" title="与C++交互"></a>与C++交互</h3><p>（待填坑）</p><h2 id="文件名、关键字与标识符"><a href="#文件名、关键字与标识符" class="headerlink" title="文件名、关键字与标识符"></a>文件名、关键字与标识符</h2><p>有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字，如：X56、group1、_x23、i、өԑ12。<br>_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table class="table table-bordered table-striped table-condensed">  <tr>    <td>break</td>    <td>default</td>    <td>func</td>    <td>interface</td>    <td>select</td>  </tr>  <tr>    <td>case</td>    <td>defer</td>    <td>go</td>    <td>map</td>    <td>struct</td>  </tr>  <tr>    <td>chan</td>    <td>else</td>    <td>goto</td>    <td>package</td>    <td>switch</td>  </tr>  <tr>    <td>const</td>    <td>fallthrough</td>    <td>if</td>    <td>range</td>    <td>type</td>  </tr>  <tr>    <td>continue</td>    <td>for</td>    <td>import</td>    <td>return</td>    <td>var</td>  </tr></table><p>下面列举了 Go 代码中会使用到的 36 个预定义标识符：</p><table class="table table-bordered table-striped table-condensed">  <tr>    <td>append</td>    <td>bool</td>    <td>byte</td>    <td>cap</td>    <td>close</td>    <td>complex</td>    <td>complex64</td>    <td>complex128</td>    <td>uint16</td>  </tr>  <tr>    <td>copy</td>    <td>false</td>    <td>float32</td>    <td>float64</td>    <td>imag</td>    <td>int</td>    <td>int8</td>    <td>int16</td>    <td>uint32</td>  </tr>  <tr>    <td>int32</td>    <td>int64</td>    <td>iota</td>    <td>len</td>    <td>make</td>    <td>new</td>    <td>nil</td>    <td>panic</td>    <td>uint64</td>  </tr>  <tr>    <td>print</td>    <td>println</td>    <td>real</td>    <td>recover</td>    <td>string</td>    <td>true</td>    <td>uint</td>    <td>uint8</td>    <td>uintptr</td>  </tr></table><h2 id="包的概念，导入"><a href="#包的概念，导入" class="headerlink" title="包的概念，导入"></a>包的概念，导入</h2><p>包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。</p><p>你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p><p><em>标准库</em></p><p>在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。</p><p>Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>这是定义一个函数最简单的格式：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">functionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。</p><p>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 undefined: main.main。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> main must have no arguments and no <span class="token keyword">return</span> values results<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。</p><p>多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</p><h2 id="数据类型与声明"><a href="#数据类型与声明" class="headerlink" title="数据类型与声明"></a>数据类型与声明</h2><p>变量（或常量）包含数据，这些数据可以有不同的数据类型，简称类型。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。</p><p>类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。</p><p>结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。</p><p>下面是我学习用写的一个程序：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment" spellcheck="true">// Go语言推荐使用驼峰式命名</span><span class="token comment" spellcheck="true">// var studentName string</span><span class="token comment" spellcheck="true">//声明变量</span><span class="token comment" spellcheck="true">//var a string</span><span class="token comment" spellcheck="true">//var b int</span><span class="token comment" spellcheck="true">//var c bool</span><span class="token comment" spellcheck="true">//批量声明</span><span class="token keyword">var</span> <span class="token punctuation">(</span>                a <span class="token builtin">string</span>        <span class="token comment" spellcheck="true">// ""空字符串</span>                b <span class="token builtin">int</span>   <span class="token comment" spellcheck="true">// 0</span>                c <span class="token builtin">bool</span>  <span class="token comment" spellcheck="true">// false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//常量</span><span class="token keyword">const</span> pi <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token number">2.7182</span><span class="token keyword">const</span> <span class="token punctuation">(</span>        statusOK <span class="token operator">=</span> <span class="token number">200</span>        notFound <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//批量声明常量时如果没有赋值，默认和上一行一样</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                n1 <span class="token operator">=</span> <span class="token number">100</span>                n2                n3<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//const中iota第一次出现时被重置为0，之后没新增一行const都会递增，类似枚举</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                a1 <span class="token operator">=</span> <span class="token boolean">iota</span>       <span class="token comment" spellcheck="true">// 0</span>                a2                      <span class="token comment" spellcheck="true">// 1 </span>                a3                      <span class="token comment" spellcheck="true">// 2</span>                a4                      <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                b1 <span class="token operator">=</span> <span class="token boolean">iota</span>       <span class="token comment" spellcheck="true">// 0</span>                b2                      <span class="token comment" spellcheck="true">// 1</span>                <span class="token boolean">_</span>                       <span class="token comment" spellcheck="true">// 2</span>                b3                      <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//插队</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                c1 <span class="token operator">=</span> <span class="token boolean">iota</span>       <span class="token comment" spellcheck="true">// 0</span>                c2 <span class="token operator">=</span> <span class="token number">100</span>        <span class="token comment" spellcheck="true">// 100</span>                c3 <span class="token operator">=</span> <span class="token boolean">iota</span>       <span class="token comment" spellcheck="true">// 2</span>                c4                      <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//多个常量声明在一行</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                d1<span class="token punctuation">,</span> d2 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">2</span>             <span class="token comment" spellcheck="true">//d1:1, d2:2</span>                d3<span class="token punctuation">,</span> d4 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">2</span>             <span class="token comment" spellcheck="true">//d3:2, d4:3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//定义数量级</span><span class="token keyword">const</span> <span class="token punctuation">(</span>                <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token boolean">iota</span>                KB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>                MB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>                GB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>                TB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>                PB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                a <span class="token operator">=</span> <span class="token string">"理想"</span>                b <span class="token operator">=</span> <span class="token number">16</span>                c <span class="token operator">=</span> <span class="token boolean">true</span>                <span class="token comment" spellcheck="true">//Go语言中非全局变量变量声明必须使用，否则编译不过</span>                fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//在终端中输出要打印的内容</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"name:%s\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// %s:占位符</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">// 打印完自动加一个换行符</span>                <span class="token comment" spellcheck="true">//声明变量同时赋值</span>                <span class="token keyword">var</span> s1 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"whb"</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//类型推导（根据值判断该变量是什么类型）</span>                <span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token string">"20"</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//简短变量声明，只能在函数内使用</span>                s3 <span class="token operator">:=</span> <span class="token string">"哈哈哈"</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//匿名变量</span>                <span class="token comment" spellcheck="true">//_</span><span class="token comment" spellcheck="true">//注意事项:</span><span class="token comment" spellcheck="true">//1.函数外每个语句必须以关键字开始(var, const, func)</span><span class="token comment" spellcheck="true">//2. :=不能用于函数外</span><span class="token comment" spellcheck="true">//3. _多用于占位，表示忽略值</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"注意事项:\n1.函数外每个语句必须以关键字开始(var, const, func)\n2. :=不能用于函数外\n3. _多用于占位，表示忽略值"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go程序的一般结构"><a href="#Go程序的一般结构" class="headerlink" title="Go程序的一般结构"></a>Go程序的一般结构</h2><p>Go 程序的结构顺序如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><p>Go 程序的执行（程序启动）顺序如下：</p><ul><li>按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：</li><li>如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。</li><li>然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。</li><li>在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><pre class="line-numbers language-go"><code class="language-go">valueOfTypeB <span class="token operator">=</span> <span class="token function">typeB</span><span class="token punctuation">(</span>valueOfTypeA<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>类型 B 的值 = 类型 B(类型 A 的值)</em></p><p>示例：</p><pre class="line-numbers language-go"><code class="language-go">a <span class="token operator">:=</span> <span class="token number">5.0</span>b <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><p>变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。</p><p>每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。</p><p>一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。</p><p>示例：init.go</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> trans<span class="token keyword">import</span> <span class="token string">"math"</span><span class="token keyword">var</span> Pi <span class="token builtin">float64</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   Pi <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> math<span class="token punctuation">.</span><span class="token function">Atan</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// init() function computes Pi</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在它的 init 函数中计算变量 Pi 的初始值。</p><p>示例：user_init.go 中导入了包 trans（需要init.go目录为./trans/init.go）并且使用到了变量 Pi：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>   <span class="token string">"fmt"</span>   <span class="token string">"./trans"</span><span class="token punctuation">)</span><span class="token keyword">var</span> twoPi <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> trans<span class="token punctuation">.</span>Pi<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"2*Pi = %g\n"</span><span class="token punctuation">,</span> twoPi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2*Pi = 6.283185307179586</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch-Linux-Install-Advanced</title>
      <link href="/2020/01/26/arch-linux-install-advanced/"/>
      <url>/2020/01/26/arch-linux-install-advanced/</url>
      
        <content type="html"><![CDATA[<h2 id="Arch-Linux-折腾日常之基本系统的配置和KDE桌面环境的安装"><a href="#Arch-Linux-折腾日常之基本系统的配置和KDE桌面环境的安装" class="headerlink" title="Arch Linux 折腾日常之基本系统的配置和KDE桌面环境的安装"></a>Arch Linux 折腾日常之基本系统的配置和KDE桌面环境的安装</h2><p>进入刚刚安装的 Arch Linux 使用root登录</p><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><ul><li><p>有线和USB网络共享</p><pre class="line-numbers language-sh"><code class="language-sh">dhcpcd <网卡型号><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>无线</p><pre class="line-numbers language-sh"><code class="language-sh">wifi-menudhcpcd <网卡型号><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a id="more"></a><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4></li></ul><pre class="line-numbers language-sh"><code class="language-sh">useradd -m -G wheel,adm -s /bin/bash lanan    # aaron替换为你喜欢的用户名, 不能大写passwd lanan                                  # 设置用户密码EDITOR=vim visudo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这时会进入vim的操作界面, 取消<code># %wheel ALL=(ALL) ALL</code>的注释即删除那个#号即可</p><h4 id="启用32位支持、添加Archlinuxcn源和aur-helper"><a href="#启用32位支持、添加Archlinuxcn源和aur-helper" class="headerlink" title="启用32位支持、添加Archlinuxcn源和aur helper"></a>启用32位支持、添加Archlinuxcn源和aur helper</h4><ul><li><p>启用32位支持, 即启用archlinux的[multilib], 它里面有一些32位程序, 如<code>steam</code>, <code>wine</code>等；启用很简单, 取消<code>/etc/pacman.conf</code>相应的注释即可</p><pre class="line-numbers language-sh"><code class="language-sh">#[multilib]#Include = /etc/pacman.d/mirrorlist#Color#VerbosePkgLists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>取消Color的注释可以让pacman彩色输出, 而VerbosePkgLists则是升级软件时, 可以查看新旧软件对比</p></li><li><p>添加Archlinuxcn社区源, 里面打包了aur上国人常用软件和一些软件的Linux版本, 在<code>/etc/pacman.conf</code>中加入</p><pre class="line-numbers language-sh"><code class="language-sh">[archlinuxcn]SigLevel = TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch     # 可自行替换其他镜像源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再使用<code>pacman -Syy archlinuxcn-keyring</code>安装该源所需的密钥</p><p>ps：有时添加密钥出错, 可进行如下操作</p><pre class="line-numbers language-sh"><code class="language-sh">rm -rf /etc/pacman.d/gnupgpacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcnpacman -Syy archlinuxcn-keyring<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>aur helper可以让你快速便捷地安装aur上的软件, yay是用Go语言写的, 操作与pacman类似的aur helper, 在archlinuxcn源中就有</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S yay     # 即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="安装Xorg服务"><a href="#安装Xorg服务" class="headerlink" title="安装Xorg服务"></a>安装Xorg服务</h4><ul><li><p>Xorg服务</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S xorg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需安装该软件包组即可</p></li><li><p>触摸板驱动</p><p>在KDE上需要<code>xf86-input-synaptics</code>来设置触摸板, 而gnome使用<code>xf86-input-libinput</code>即可统一管理输入设备</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S xf86-input-libinput xf86-input-synaptics ln -sf /usr/share/X11/xorg.conf.d/40-libinput.conf \/etc/X11/xorg.conf.d/40-libinput.conf     # 初始化输入设备配置ln -sf /usr/share/X11/xorg.conf.d/70-synaptics.conf \/etc/X11/xorg.conf.d/70-synaptics.conf    # 初始化触摸板配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h4><ul><li><p>intel核显开源驱动</p><p>intel开源驱动已经在kernel中集成, 即<code>modesetting</code>,但要确保内核参数中没有<code>nomodeset</code>或<code>vga=</code></p><p><code>xf86-video-intel</code>是Xorg上的intel显卡驱动, 可不安装, 它提供了Xorg上的2D加速服务, 但arch wiki上不建议安装该驱动, 可能在一些显卡上有问题, 若需安装, 也请使用<code>modesetting</code>提供驱动</p><p><code>mesa</code>提供了3D加速的DRI驱动和OpenGL支持, <code>lib32-mesa</code>为32位应用提供该支持, <code>vulkan-intel</code>提供vulkan支持, <code>intel-media-driver</code>提供VA-API视频硬件加速支持（&gt;=Broadwell）</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S mesa vulkan-intel intel-media-driver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还需设置<code>LIBVA_DRIVER_NAME</code>环境变量才可启用VA-API视频硬件加速支持</p><pre class="line-numbers language-sh"><code class="language-sh">echo 'export LIBVA_DRIVER_NAME=iHD' > /etc/profile.d/va-api.shchmod a+x /etc/profile.d/va-api.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>NVIDIA独显闭源驱动</p><p>lts内核安装<code>nvidia-lts</code>, 需要使用图形界面设置可安装<code>nvidia-settings</code>, 提供VDPAU视频硬件加速和其他特性可安装<code>nvidia-utils</code></p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S nvidia-lts nvidia-settings nvidia-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>双显卡笔记本可采用optimus-manager来管理, 具体可见Arch Wiki</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S optimus-manager optimus-manager-qt nvidia-prime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于视频硬件加速, 可在vlc中启用, 有VA-API和VDPAU两种, 其中VDPAU是NVIDIA提供的, 使用N卡才会有</p></li></ul><h4 id="安装KDE"><a href="#安装KDE" class="headerlink" title="安装KDE"></a>安装KDE</h4><pre class="line-numbers language-sh"><code class="language-sh">pacman -S plasma kdebase kdegraphics    # 安装KDE桌面和部分工具pacman -S sddm sddm-kcm                 # 安装KDE登录界面pacman -S latte-dock                    # KDE上好用的dock栏systemctl enable sddm                   # 设置登录界面自启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装网络管理模块和挂载MTP工具"><a href="#安装网络管理模块和挂载MTP工具" class="headerlink" title="安装网络管理模块和挂载MTP工具"></a>安装网络管理模块和挂载MTP工具</h4><ul><li><p>网络管理</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S networkmanagersystemctl enable NetworkManager       # 设置网络管理模块自启动 注意大小写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>蓝牙管理</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S bluez bluez-utils pulseaudio-modules-btpacman -S alsa-utils alsa-firmware alsa-plugins pulseaudio-alsausermod -aG lp aaron              # 添加用户到lp组以控制蓝牙systemctl enable bluetooth        # 设置蓝牙模块开机自启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>pulseaudio-modules-bt</code>提供了蓝牙耳机或音箱的输出支持, 博通的蓝牙芯片需要再aur中加装驱动比如<code>bluez-firmware</code></p></li><li><p>MTP</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S libmtp mtpfspacman -S android-tools android-udev    # 可选, 使用adb管理手机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若果用Gnome类的文件管理器, 可以安装<code>gvfs-mtp</code>, KDE的话, 安装<code>kio-extras</code>获得更好体验</p></li></ul><hr><h4 id="重启即可看到图形界面"><a href="#重启即可看到图形界面" class="headerlink" title="重启即可看到图形界面"></a>重启即可看到图形界面</h4><hr><h4 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h4><ul><li><p>使用fontconfig</p><p>我个人使用了fontconfig来让字体更好的渲染, 我用到的是<code>noto-fonts</code>、<code>noto-fonts-cjk</code>、<code>noto-fonts-emoji</code>和<code>FuraCode-Nerd-Font</code>, 前面三个archlinuxcn源有打包, 最后一个我是在<code>nerd-font</code>项目上下载的, 主要来使用zsh主题, 个人的fontconfig借鉴了<a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener">Linux下的字体调校指南</a>上的配置, 在dotfiles文件夹里</p><pre class="line-numbers language-sh"><code class="language-sh">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将font.conf扔进个人home中的<code>.config/fontconfig</code>中重新登录即可看到效果</p></li><li><p>不使用fontconfig</p><p>推荐安装思源系列字体, 在KDE中设置即可</p><pre class="line-numbers language-sh"><code class="language-sh">sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="更改语言"><a href="#更改语言" class="headerlink" title="更改语言"></a>更改语言</h4><pre class="line-numbers language-sh"><code class="language-sh">sudo sh -c "echo 'LANG=zh_CN.UTF-8' > /etc/locale.conf"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新登录即可</p><h4 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h4><ul><li><p>fcitx &amp; google-pinyin</p><pre class="line-numbers language-sh"><code class="language-sh">sudo pacman -S fcitx fcitx-configtool fcitx-im fcitx-googlepinyin kcm-fcitxecho 'export GTK_IM_MODULE=fcitx' > .xprofileecho 'export QT_IM_MODULE=fcitx' >> .xprofileecho 'export XMODIFIERS=@im=fcitx' >> .xprofile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经典的fcitx输入法框架</p></li><li><p>fcitx5 &amp; 中州韵(fcitx-rime)输入引擎</p><pre class="line-numbers language-sh"><code class="language-sh">sudo pacman -S fcitx5-git fcitx5-gtk-git fcitx5-qt5-git fcitx5-rime-git kcm-fcitx5-git fcitx5-chinese-addons-gitecho 'export GTK_IM_MODULE=fcitx5' > .xprofileecho 'export QT_IM_MODULE=fcitx5' >> .xprofileecho 'export XMODIFIERS=@im=fcitx5' >> .xprofileecho 'fcitx5 &' >> .xprofile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fcitx5是下一代fcitx输入法框架, 相关软件在archlinuxcn源中</p></li></ul><p>重启后生效</p><h4 id="安装TLP笔记本电源管理系统"><a href="#安装TLP笔记本电源管理系统" class="headerlink" title="安装TLP笔记本电源管理系统"></a>安装TLP笔记本电源管理系统</h4><pre class="line-numbers language-sh"><code class="language-sh">sudo pacman -S tlp tlp-rdw ethtool smartmontools    # 安装TLPsudo systemctl enable tlp.servicesudo systemctl enable tlp-sleep.service             # 设置TLP自启动sudo systemctl mask systemd-rfkill.servicesudo systemctl mask systemd-rfkill.socket           # 屏蔽部分服务以免冲突<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启后生效</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://wiki.archlinux.org/index.php/General_recommendations" target="_blank" rel="noopener">ArchLinux’s General recommendations</a></li><li><a href="https://wiki.archlinux.org/index.php/General_recommendations_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">ArchLinux’s General recommendations中文译版</a></li><li><a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/" target="_blank" rel="noopener">Linux下的字体调教指南</a></li><li><a href="https://ohmyarch.github.io/2017/01/15/Linux%E4%B8%8B%E7%BB%88%E6%9E%81%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">Linux下终极字体配置方案</a></li><li><a href="https://github.com/limbostray/oh-my-arch" target="_blank" rel="noopener">oh-my-arch</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Archlinux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux Install</title>
      <link href="/2020/01/26/arch-linux-install/"/>
      <url>/2020/01/26/arch-linux-install/</url>
      
        <content type="html"><![CDATA[<h3 id="Arch-Linux-折腾日常之基本系统的安装"><a href="#Arch-Linux-折腾日常之基本系统的安装" class="headerlink" title="Arch Linux 折腾日常之基本系统的安装"></a>Arch Linux 折腾日常之基本系统的安装</h3><p>Arch Linux是我最喜欢的发行版之一, 它接近上游, 可以体验到最新的软件包；系统可以自行定制却没LFS那么折腾, 我这样对Linux晓得一点皮毛的人也可以上手, 但这也可能是我无法发挥Arch的威力的原因。@~@</p><p>我的配置：技嘉笔记本AORUS-15-X9,因为它物理屏蔽核显,导致我研究了好久,呜呜呜呜呜呜。在这篇博客中我将介绍无论是否屏蔽核显都通用的方法,下面正式开始</p><h4 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h4><p>将archlinux的iso烧录到U盘</p><pre class="line-numbers language-sh"><code class="language-sh">sudo umount /dev/sdX*                  # 卸载U盘sudo dd if=./archlinux.iso of=/dev/sdX \oflag=sync status=progress bs=4M       # 烧录iso<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><a id="more"></a><h4 id="启动到Live-CD"><a href="#启动到Live-CD" class="headerlink" title="启动到Live CD"></a>启动到Live CD</h4><p>插入U盘, 启动到archlinux的Live CD</p><p>ps：N卡最好在启动时按下e并在末尾加入 “modprobe.blacklist=nouveau” 以禁用 nouveau 开源驱动, 否则可能花屏或者出现其他莫名bug</p><h4 id="验证启动模式"><a href="#验证启动模式" class="headerlink" title="验证启动模式"></a>验证启动模式</h4><pre class="line-numbers language-sh"><code class="language-sh">ls /sys/firmware/efi/efivars<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有结果, 系统就是以UEFI模式启动的, 否则是BIOS模式启动的, 我的笔记本是UEFI模式启动</p><h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><p>可以用<code>ip link</code>查看自己的网卡型号, en打头的是有线, 比如宽带或者手机USB网络共享, wl打头是无线网卡的型号。我的笔记本在archlinux的Live CD下可以看到eno1和wlan0</p><ul><li><p>有线</p><p>插了网线的的启动Live CD时就会用dhcpcd获取有线的ip地址, 也可以ping一下百度测试一下</p></li><li><p>无线</p><pre class="line-numbers language-sh"><code class="language-sh">wifi-menu                 # 连接wifidhcpcd wlan0              # 获取ip地址ping -c4 www.baidu.com    # 测试连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>wlan0 替换为你自己的无线网卡型号就行</p></li><li><p>USB网络共享</p><pre class="line-numbers language-sh"><code class="language-sh">dhcpcd <网卡型号>         # 即可自动获取ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h4><pre class="line-numbers language-sh"><code class="language-sh">vim /etc/pacman.d/mirorrlist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个mirrorlist在会复制到接下来安装的系统中, 我在第一行加入了下面的(东软)镜像源, 可自行更换 </p><pre class="line-numbers language-sh"><code class="language-sh">Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h4><pre class="line-numbers language-sh"><code class="language-sh">timedatectl set-ntp truetimedatectl status       # 可选, 查看系统现在的时间状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><ul><li><p>我的分区方案：</p><table><thead><tr><th>挂载点</th><th>分区类型</th><th>大小</th><th>文件系统</th></tr></thead><tbody><tr><td>/boot/efi</td><td>EFI系统分区(EF00)</td><td>512MB</td><td>fat32</td></tr><tr><td>/</td><td>Linux 根目录(8300)</td><td>50GB</td><td>xfs</td></tr><tr><td>/home</td><td>个人数据目录(8300)</td><td>200GB</td><td>xfs</td></tr><tr><td>[SWAP]</td><td>Linux swap交换分区(8200)</td><td>4GB</td><td>swap</td></tr></tbody></table><p>GPT分区表最好使用 gdisk 命令或者 cgdisk 交互命令</p><pre class="line-numbers language-sh"><code class="language-sh">gdisk /dev/nvme0n1     # 更换为自己想要安装到的硬盘<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nvme一般是m.2接口的硬盘, sata的硬盘可能是sda、sdb什么的</p><p>分完区可以用 lsblk 命令检查一下</p></li><li><p>格式化和挂载分区</p><pre class="line-numbers language-sh"><code class="language-sh">mkfs.fat -F32 /dev/nvme0n1p1          # 格式化efi分区mkfs.xfs /dev/nvme0n1p2               # 格式化root分区mkfs.xfs /dev/nvme0n1p3               # 格式化home分区mkswap /dev/nvme0n1p4                 # 格式化swap分区swapon /dev/nvme0n1p4                 # 启用swapmount /dev/nvme0n1p2 /mnt             # 把root分区挂载到/mntmkdir -p /mnt/boot/efi /mnt/home      # 建立/boot/efi和/home目录mount /dev/nvme0n1p1 /mnt/boot/efi    # 挂载efi分区到/boot/efimount /dev/nvme0n1p3 /mnt/home        # 挂载home分区到/home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><pre class="line-numbers language-sh"><code class="language-sh">pacstrap /mnt base base-devel linux-lts linux-lts-headers linux-firmware\dosfstools xfsprogs sysfsutils inetutils net-tools dhcpcd netctl iw wpa_supplicant dialog\less vim man-db man-pages bash-completion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>base组更改之后需要加装很多东西, 管理文件系统的、联网的、文本编辑的……</p><p>基本系统：<code>base</code>、<code>base-devel</code> 其中<code>base-devel</code>包含很多开发所需工具</p><p>Linux内核：<code>linux-lts</code>、<code>linux-lts-headers</code>, 我安装的是LTS的Linux, bug会少一些, ArchLinux中有许多为不是使用主线稳定内核的用户提供<code>dkms</code>版的软件, 需要内核对应的<code>headers</code>来安装</p><p>大部分驱动：<code>linux-firmware</code></p><p>管理文件系统：<code>xfsprogs</code>、<code>dosfstool</code>、<code>sysfsutils</code>, 管理xfs、fat32等文件系统</p><p>网络连接所需工具：<code>inetutils</code>、<code>net-tools</code>、<code>dhcpcd</code>、<code>netctl</code>、<code>iw</code>、<code>wpa_supplicant</code>、<code>dialog</code> 来管理有线和无线连接</p><p>文本浏览和编辑工具：<code>less</code>、<code>vim</code></p><p>man系统手册：<code>man-db</code>、<code>man-pages</code></p><p>为了等下可以补全部分命令安装<code>bash-completion</code></p><h4 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h4><ul><li><p>Fstab</p><p>生成fstab文件</p><pre class="line-numbers language-sh"><code class="language-sh">genfstab -U /mnt >> /mnt/etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建议用vim查看一下生成后的fstab<code>vim /mnt/etc/fstab</code></p></li><li><p>Chroot</p><p>Change root 到刚刚安装的系统</p><pre class="line-numbers language-sh"><code class="language-sh">arch-chroot /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>本地化</p><ul><li><p>时区</p><pre class="line-numbers language-sh"><code class="language-sh">ln -sf /usr/share/zoneinfo/Asia/Shanghai \/etc/localtime       # 更改时区hwclock --systohc    # 应用到硬件时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>语言</p><pre class="line-numbers language-sh"><code class="language-sh">vim /etc/locale.gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移除下列语言的注释(#)即可</p><pre class="line-numbers language-sh"><code class="language-sh">en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">locale-genecho 'LANG=en_US.UTF-8' > /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成语言信息, 然后更改语言环境为英文, 避免乱码</p></li></ul></li><li><p>网络配置</p><pre class="line-numbers language-sh"><code class="language-sh">echo 'AORUS-X9' > /etc/hostnamevim /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AORUS-X9是我自己的主机名, 自己更改为喜欢的名字即可, 下面的主机名也要随着该</p><p>加入以下内容</p><pre class="line-numbers language-sh"><code class="language-sh">127.0.0.1       localhost::1             localhost127.0.1.1       AORUS-X9.localdomain    AORUS-X9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Initramfs</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -Syy intel-ucode    # 安装intel微码mkinitcpio -p linux-lts    # 生成initramfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设定Root密码</p><pre class="line-numbers language-sh"><code class="language-sh">passwd     # 即可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h4><pre class="line-numbers language-sh"><code class="language-sh">pacman -S grub efibootmgr os-probergrub-install --target=x86_64-efi --efi-directory=/boot/efi \--bootloader-id=GRUB_ARCH --recheck      # 安装grub引导grub-mkconfig -o /boot/grub/grub.cfg     # 生成grub配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若是多系统, 需要将其他系统的efi分区挂载, 然后再使用上述最后一条命令重新生成grub配置即可</p><p>####安装暂时用的NVIDIA驱动(选做)</p><pre class="line-numbers language-sh"><code class="language-sh">pacman -S nvidia-lts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我的笔记本屏蔽了核显,因此需要安装NVIDIA驱动才能在下一步的重启后不花屏,下篇文章会介绍安装完整的NVIDIA驱动</p><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><pre class="line-numbers language-sh"><code class="language-sh">exitumount -a    # 卸载已挂载的文件系统reboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若是N卡, 建议在重启启动时grub中按e添加参数, 在linux所在行行尾添加 “modprobe.blacklist=nouveau”再按Ctrl + x启动即可</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">ArchLinux‘s Install Guide</a></li><li>ArchLinux’s Install Guide中文译版</li><li><a href="https://github.com/limbostray/oh-my-arch" target="_blank" rel="noopener">oh-my-arch</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Archlinux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-Primer第一章练习</title>
      <link href="/2020/01/26/cpp-primer-di-yi-zhang-lian-xi/"/>
      <url>/2020/01/26/cpp-primer-di-yi-zhang-lian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-one-exercises-正在更新"><a href="#Chapter-one-exercises-正在更新" class="headerlink" title="Chapter one exercises (正在更新)"></a>Chapter one exercises (正在更新)</h1><p><strong>exercise-1.1</strong></p><pre class="line-numbers language-c++"><code class="language-c++">int main() {    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><a id="more"></a><p><strong>exercise-1-2</strong></p><p><del>懒得更新了</del></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020跨年文案</title>
      <link href="/2020/01/24/2020-kua-nian-wen-an/"/>
      <url>/2020/01/24/2020-kua-nian-wen-an/</url>
      
        <content type="html"><![CDATA[<h1 id="Happy-2020"><a href="#Happy-2020" class="headerlink" title="Happy 2020"></a>Happy 2020</h1><p>​    走到一年的尾巴上时，总有一种奇异心绪。</p><p>​    一方面，总觉得又是虚度了三百日光阴，仍然没有什么长进。另一方面，又劝说自己可以做的不好也没有什么，大不了及时清零，2020年再去“收拾旧山河”。我不知道会不会有朝一日，我变得不再奢望，安于现状。</p><p>​    但至少，要在彻底沦为庸庸碌碌之前，打磨出更多些的光亮。</p><p>​    2020年，我还想试试。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
